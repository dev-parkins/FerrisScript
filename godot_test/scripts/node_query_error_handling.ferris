// Example: Error Handling Best Practices
// Demonstrates safe node query patterns
//
// GODOT SCENE SETUP:
// 1. Create a new 2D Scene
// 2. Add FerrisScriptNode as root, rename to "Main"
// 3. Attach this script to Main node
// 4. Add child nodes to Main:
//    - Node2D named "Player" (required for demonstration)
//    - Node2D named "UI" → child "HUD" → child "HealthBar" (nested path test)
//    - Node2D named "OptionalFeature" (can be omitted to test optional logic)
//    - Node2D named "RequiredSystem" (should exist for required validation)
//
// Scene Tree Structure:
// /root
//   └─ Main (FerrisScriptNode with this script)
//        ├─ Player
//        ├─ UI
//        │    └─ HUD
//        │         └─ HealthBar
//        ├─ OptionalFeature (optional - omit to see error handling)
//        └─ RequiredSystem (required - omit to see error message)
//
// EXPECTED BEHAVIOR:
// - Script prints output to Godot Output panel (View → Output)
// - Shows ✓ for found nodes, ✗ for missing required nodes, ○ for optional/info
// - With all nodes: All ✓ markers shown
// - Without OptionalFeature: Shows "OptionalFeature not found (this is OK)"
// - Without RequiredSystem: Shows "ERROR: RequiredSystem node not found!"
// - Demonstrates safe patterns: validate with has_node() before get_node()

fn _ready() {
    print("=== Error Handling Example ===");
    
    // GOOD: Validate before accessing
    if has_node("Player") {
        let player = get_node("Player");
        print("✓ Found Player node");
    } else {
        print("✗ Player node not found!");
    }
    
    // BAD: Direct access without validation
    // let player = get_node("Player"); // May error if Player doesn't exist
    
    // GOOD: Check parent exists
    let parent = get_parent();
    print("✓ Parent exists (every node has parent except root)");
    
    // GOOD: Validate complex paths
    if has_node("UI/HUD/HealthBar") {
        let health_bar = get_node("UI/HUD/HealthBar");
        print("✓ Found HealthBar at UI/HUD/HealthBar");
    } else {
        print("✗ HealthBar path not found");
    }
    
    // Call other demonstration functions
    print("");
    safe_node_access();
    print("");
    dynamic_nodes();
    print("");
    hierarchy_navigation();
    print("");
    print("=== Example Complete ===");
}

fn safe_node_access() {
    print("--- Safe Node Access Patterns ---");
    
    // Pattern 1: Optional node access
    if has_node("OptionalFeature") {
        let feature = get_node("OptionalFeature");
        print("✓ Found optional OptionalFeature node");
    } else {
        print("○ OptionalFeature not found (this is OK, it's optional)");
    }
    
    // Pattern 2: Required node validation
    if !has_node("RequiredSystem") {
        print("✗ ERROR: RequiredSystem node not found!");
    } else {
        let system = get_node("RequiredSystem");
        print("✓ Found required RequiredSystem node");
    }
}

fn dynamic_nodes() {
    print("--- Dynamic Node Handling ---");
    
    // Check for dynamically spawned nodes
    if has_node("Projectiles/Bullet_001") {
        let bullet = get_node("Projectiles/Bullet_001");
        print("✓ Found dynamically spawned bullet");
    } else {
        print("○ No bullets spawned yet");
    }
    
    // Search for named children without knowing structure
    let target_marker = find_child("HealthBar");
    print("✓ Found HealthBar via recursive search");
}

fn hierarchy_navigation() {
    print("--- Hierarchy Navigation ---");
    
    // Get parent for relative navigation
    let parent = get_parent();
    print("✓ Got parent node");
    
    // Check for UI sibling
    if has_node("UI") {
        print("✓ Found UI sibling node");
    } else {
        print("○ UI node not found");
    }
    
    // Note: Advanced relative paths like "../Sibling" and chained get_parent()
    // calls are not yet supported in Phase 3, coming in future phases
    print("○ Advanced navigation (../, chaining) coming in future phases");
}
