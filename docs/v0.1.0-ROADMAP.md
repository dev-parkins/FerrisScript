# FerrisScript v0.1.0 Roadmap ü¶Ä

**Version**: 0.1.0 (Minor Release)  
**Target Date**: TBD (After v0.0.2-v0.0.X)  
**Focus**: New language features, enhanced Godot integration

---

## üìã Overview

**Semantic Versioning Context**:

- v0.0.X = Patch releases (bug fixes, documentation)
- v0.X.0 = **Minor releases** (new features, backward compatible)
- vX.0.0 = Major releases (breaking changes)

**v0.1.0 Vision**:
Transform FerrisScript from a proof-of-concept to a **practical scripting language** for Godot game development. Focus on features that enable real game development workflows.

---

## üéØ Core Goals

1. **Make FerrisScript usable for simple 2D games**
   - Enable common game patterns (arrays, loops, collections)
   - Support essential Godot types
   - Enable basic game logic implementation

2. **Improve developer experience**
   - Add tooling (syntax highlighting, snippets)
   - Better error messages
   - Faster iteration

3. **Validate architecture**
   - Ensure design scales to more features
   - Identify pain points early
   - Set foundation for v0.2.0+

---

## ‚ú® New Language Features

### High Priority (Must-Have for v0.1.0)

#### 1. Array/List Types

**Status**: üî¥ Not Started  
**Priority**: Critical  
**Rationale**: Essential for game development (inventory, enemies, bullets, etc.)

**Scope**:

- [ ] Array type syntax: `[i32]`, `[String]`, etc.
- [ ] Array literals: `[1, 2, 3]`
- [ ] Indexing: `arr[0]`, `arr[i]`
- [ ] Length: `arr.len()`
- [ ] Push/pop operations: `arr.push(5)`, `arr.pop()`
- [ ] Array methods: `contains()`, `clear()`, `remove_at()`
- [ ] Type checking for homogeneous arrays
- [ ] Integration with Godot Array type

**Example**:

```rust
let mut enemies: [Node] = [];

fn _ready() {
    enemies.push(get_node("Enemy1"));
    enemies.push(get_node("Enemy2"));
    print(enemies.len()); // 2
}

fn _process(delta: f32) {
    let mut i: i32 = 0;
    while i < enemies.len() {
        // Process each enemy
        i += 1;
    }
}
```

**Tests**: ~15-20 new tests
**Estimated Effort**: 5-7 days

---

#### 2. For Loops

**Status**: üî¥ Not Started  
**Priority**: Critical  
**Rationale**: Much cleaner than while loops for iteration

**Scope**:

- [ ] Range syntax: `for i in 0..10`
- [ ] Array iteration: `for enemy in enemies`
- [ ] Inclusive ranges: `for i in 0..=10`
- [ ] Break statement
- [ ] Continue statement
- [ ] Nested loops

**Example**:

```rust
fn _process(delta: f32) {
    // Range loop
    for i in 0..10 {
        print(i);
    }
    
    // Array iteration
    for enemy in enemies {
        enemy.position.x += 10.0;
    }
}
```

**Tests**: ~10-15 new tests
**Estimated Effort**: 3-5 days

---

#### 3. Match Expressions

**Status**: üî¥ Not Started  
**Priority**: High  
**Rationale**: Rust's killer feature, essential for state machines

**Scope**:

- [ ] Match on integers: `match x { 1 => ..., 2 => ..., _ => ... }`
- [ ] Match on booleans
- [ ] Match on strings
- [ ] Exhaustiveness checking
- [ ] Match guards (if needed)
- [ ] Match with blocks

**Example**:

```rust
let mut state: String = "idle";

fn _process(delta: f32) {
    match state {
        "idle" => {
            // Idle behavior
        },
        "walking" => {
            self.position.x += 50.0 * delta;
        },
        "jumping" => {
            self.position.y -= 100.0 * delta;
        },
        _ => {
            print("Unknown state!");
        }
    }
}
```

**Tests**: ~15-20 new tests
**Estimated Effort**: 5-7 days

---

#### 4. String Interpolation

**Status**: üî¥ Not Started  
**Priority**: Medium  
**Rationale**: Much nicer than string concatenation

**Scope**:

- [ ] Format string syntax: `f"Hello, {name}!"`
- [ ] Expression interpolation: `f"Score: {score * 10}"`
- [ ] Type conversion (int/float to string)
- [ ] Escape sequences

**Example**:

```rust
let name: String = "Player";
let score: i32 = 100;

fn _ready() {
    print(f"Hello, {name}! Your score is {score}.");
    print(f"Double score: {score * 2}");
}
```

**Tests**: ~8-10 new tests
**Estimated Effort**: 2-3 days

---

### Medium Priority (Nice-to-Have for v0.1.0)

#### 5. Enum Types

**Status**: üî¥ Not Started  
**Priority**: Medium  
**Rationale**: Great for state machines, directions, etc.

**Scope**:

- [ ] Enum definition: `enum State { Idle, Walking, Jumping }`
- [ ] Enum values: `State::Idle`
- [ ] Match on enums (combines with #3)
- [ ] Type checking

**Example**:

```rust
enum Direction {
    Up,
    Down,
    Left,
    Right
}

let dir: Direction = Direction::Right;

fn _process(delta: f32) {
    match dir {
        Direction::Up => self.position.y -= 50.0 * delta,
        Direction::Down => self.position.y += 50.0 * delta,
        Direction::Left => self.position.x -= 50.0 * delta,
        Direction::Right => self.position.x += 50.0 * delta,
    }
}
```

**Tests**: ~12-15 new tests
**Estimated Effort**: 4-5 days

---

#### 6. Struct Types

**Status**: üî¥ Not Started  
**Priority**: Medium  
**Rationale**: Custom data types for game entities

**Scope**:

- [ ] Struct definition: `struct Player { health: i32, mana: i32 }`
- [ ] Struct instantiation: `Player { health: 100, mana: 50 }`
- [ ] Field access: `player.health`
- [ ] Methods (later, for v0.2.0)

**Example**:

```rust
struct Player {
    health: i32,
    mana: i32,
    level: i32
}

let mut player: Player = Player {
    health: 100,
    mana: 50,
    level: 1
};

fn _process(delta: f32) {
    if player.health <= 0 {
        print("Game Over!");
    }
}
```

**Tests**: ~10-12 new tests
**Estimated Effort**: 5-6 days

---

### Low Priority (Consider for v0.2.0)

- [ ] Dictionary/HashMap types
- [ ] Tuple types
- [ ] Pattern matching (destructuring)
- [ ] Method calls on types
- [ ] Trait system (way future)
- [ ] Generics (way future)

---

## üéÆ Enhanced Godot Integration

### High Priority

#### 1. Additional Godot Types

**Status**: üî¥ Not Started  
**Priority**: High

**New Types to Add**:

- [ ] `Color` - RGBA colors
- [ ] `Rect2` - 2D rectangles
- [ ] `Transform2D` - 2D transformations
- [ ] `Vector3` - 3D vectors (for future 3D support)
- [ ] `Basis` - 3D rotation
- [ ] `AABB` - Axis-aligned bounding box

**Example**:

```rust
fn _ready() {
    let red: Color = Color { r: 1.0, g: 0.0, b: 0.0, a: 1.0 };
    self.modulate = red;
    
    let bounds: Rect2 = Rect2 {
        position: Vector2 { x: 0.0, y: 0.0 },
        size: Vector2 { x: 100.0, y: 100.0 }
    };
}
```

**Tests**: ~20-25 new tests
**Estimated Effort**: 3-4 days

---

#### 2. Signal Support

**Status**: üî¥ Not Started  
**Priority**: High  
**Rationale**: Core Godot feature for event-driven programming

**Scope**:

- [ ] Define signals in scripts
- [ ] Emit signals
- [ ] Connect to signals (from Godot)
- [ ] Signal with parameters

**Example**:

```rust
signal health_changed(old: i32, new: i32);

let mut health: i32 = 100;

fn take_damage(amount: i32) {
    let old_health: i32 = health;
    health -= amount;
    emit_signal("health_changed", old_health, health);
}
```

**Tests**: ~10-12 new tests
**Estimated Effort**: 5-7 days

---

#### 3. Additional Callbacks

**Status**: üî¥ Not Started  
**Priority**: Medium

**New Callbacks**:

- [ ] `_input(event: InputEvent)` - Input handling
- [ ] `_physics_process(delta: f32)` - Physics updates
- [ ] `_enter_tree()` - Node enters scene tree
- [ ] `_exit_tree()` - Node exits scene tree
- [ ] `_draw()` - Custom drawing (2D)

**Example**:

```rust
fn _input(event: InputEvent) {
    if event.is_action_pressed("jump") {
        velocity.y = -300.0;
    }
}

fn _physics_process(delta: f32) {
    // Physics code here (fixed timestep)
}
```

**Tests**: ~8-10 new tests
**Estimated Effort**: 3-4 days

---

### Medium Priority

#### 4. Custom Properties

**Status**: üî¥ Not Started  
**Priority**: Medium  
**Rationale**: Expose script variables to Godot Inspector

**Scope**:

- [ ] `@export` annotation
- [ ] Property types (int, float, string, etc.)
- [ ] Property hints (range, file, etc.)
- [ ] Read from Inspector
- [ ] Watch for changes

**Example**:

```rust
@export
let speed: f32 = 100.0;

@export(range: 0.0, 1.0)
let volume: f32 = 0.5;

fn _process(delta: f32) {
    self.position.x += speed * delta;
}
```

**Tests**: ~8-10 new tests
**Estimated Effort**: 4-5 days

---

#### 5. Node Query Functions

**Status**: üî¥ Not Started  
**Priority**: Medium

**New Functions**:

- [ ] `get_node(path: String) -> Node`
- [ ] `find_child(name: String) -> Node`
- [ ] `get_parent() -> Node`
- [ ] `get_children() -> [Node]`
- [ ] `has_node(path: String) -> bool`

**Example**:

```rust
fn _ready() {
    let player: Node = get_node("../Player");
    let children: [Node] = get_children();
    
    for child in children {
        print(child.name);
    }
}
```

**Tests**: ~10-12 new tests
**Estimated Effort**: 3-4 days

---

### Low Priority (v0.2.0+)

- [ ] Resource loading (load scenes, textures, etc.)
- [ ] Timer nodes
- [ ] Tween/animation support
- [ ] 3D support (Camera3D, MeshInstance3D, etc.)
- [ ] Advanced physics (RigidBody2D, CollisionShape2D)
- [ ] Particle systems
- [ ] Audio playback

---

## üõ†Ô∏è Tooling Improvements

### High Priority

#### 1. Language Server Protocol (LSP)

**Status**: üî¥ Not Started  
**Priority**: High  
**Rationale**: Makes FerrisScript a real development language

**Scope**:

- [ ] Basic LSP server implementation
- [ ] Syntax checking (real-time errors)
- [ ] Autocomplete (keywords, variables, functions)
- [ ] Go to definition
- [ ] Hover documentation
- [ ] VS Code extension

**Features**:

- Syntax errors as you type
- Autocomplete for variables, functions, types
- Jump to function definition
- Show type on hover

**Tests**: LSP protocol tests
**Estimated Effort**: 10-15 days (major feature)

---

#### 2. Improved Error Messages

**Status**: üî¥ Not Started  
**Priority**: High

**Improvements**:

- [ ] Show source code context in errors
- [ ] Colorized error output
- [ ] Suggest fixes ("did you mean `velocity`?")
- [ ] Error codes (E001, E002, etc.)
- [ ] Link to documentation for errors

**Before**:

```
Error: Undefined variable: velocty
```

**After**:

```
Error[E101]: Undefined variable
  --> move.ferris:5:10
   |
 5 |     self.velocty.x += 50.0;
   |          ^^^^^^^ not found in this scope
   |
help: a local variable with a similar name exists
   |
 5 |     self.velocity.x += 50.0;
   |          ^^^^^^^^
```

**Tests**: Error message tests
**Estimated Effort**: 5-7 days

---

### Medium Priority

#### 3. Hot Reload

**Status**: üî¥ Not Started  
**Priority**: Medium  
**Rationale**: Faster iteration during development

**Scope**:

- [ ] Detect file changes
- [ ] Recompile changed scripts
- [ ] Reload without restarting Godot
- [ ] Preserve state (if possible)

**Benefits**:

- Save seconds on every code change
- See changes immediately in running game
- Dramatically improves workflow

**Tests**: Integration tests
**Estimated Effort**: 7-10 days

---

#### 4. REPL (Read-Eval-Print Loop)

**Status**: üî¥ Not Started  
**Priority**: Low

**Scope**:

- [ ] Interactive FerrisScript shell
- [ ] Evaluate expressions
- [ ] Test code snippets
- [ ] Inspect variables

**Use Cases**:

- Quick testing of syntax
- Learning the language
- Debugging expressions

**Tests**: REPL tests
**Estimated Effort**: 5-7 days

---

### Low Priority (v0.2.0+)

- [ ] Debugger integration (breakpoints, stepping)
- [ ] Profiler integration
- [ ] Documentation generator
- [ ] Snippet library
- [ ] Online playground
- [ ] Package manager

---

## üöÄ Performance Improvements

### Compiler Optimizations

- [ ] **Constant folding**: Evaluate `2 + 3` at compile time ‚Üí `5`
- [ ] **Dead code elimination**: Remove unreachable code
- [ ] **Inlining**: Inline small functions
- [ ] **Type-based optimizations**: Use known types to skip checks

### Runtime Optimizations

- [ ] **Variable lookup optimization**: HashMap instead of linear scan
- [ ] **Bytecode compilation**: Compile to bytecode instead of AST interpretation
- [ ] **JIT compilation**: Consider for v0.2.0+
- [ ] **Reference counting**: Smart pointers for memory management

### Benchmarking

- [ ] Create comprehensive benchmark suite
- [ ] Compare with GDScript performance
- [ ] Track performance across versions
- [ ] Document performance characteristics

**Target**: Within 2x of GDScript performance for v0.1.0

---

## üìä Success Metrics for v0.1.0

### Quantitative Goals

- [ ] **Tests**: 200+ passing tests (current: 96)
- [ ] **Test Coverage**: ‚â• 80% (with coverage reporting)
- [ ] **Performance**: Within 2x of GDScript on benchmarks
- [ ] **Documentation**: 100% of public APIs documented
- [ ] **Examples**: 20+ example scripts covering all features

### Qualitative Goals

- [ ] **Usability**: Can build a simple 2D game (Pong, Breakout, etc.)
- [ ] **Developer Experience**: LSP makes coding pleasant
- [ ] **Error Messages**: Developers can understand and fix errors
- [ ] **Community**: 5+ external contributors
- [ ] **Adoption**: 10+ GitHub stars, 3+ forks

### Real-World Validation

- [ ] **Build a demo game**: Create a complete playable game in FerrisScript
  - Target: Pong or Breakout clone
  - Use arrays, loops, match expressions
  - Use Godot integration features
  - Document the experience

- [ ] **Get external feedback**: Have 3-5 developers try FerrisScript
  - Collect pain points
  - Prioritize improvements
  - Validate use cases

---

## üóìÔ∏è Development Phases

### Phase 1: Core Language Features (8-12 weeks)

1. Arrays (2 weeks)
2. For loops (1 week)
3. Match expressions (2 weeks)
4. String interpolation (1 week)
5. Enums (1-2 weeks)
6. Structs (2 weeks)
7. Testing & bug fixes (1-2 weeks)

### Phase 2: Godot Integration (4-6 weeks)

1. Additional types (1-2 weeks)
2. Signal support (2 weeks)
3. Additional callbacks (1 week)
4. Node query functions (1 week)
5. Testing & integration (1 week)

### Phase 3: Tooling (6-8 weeks)

1. LSP foundation (3-4 weeks)
2. Error message improvements (1-2 weeks)
3. Hot reload (2 weeks)
4. VS Code extension polish (1 week)

### Phase 4: Polish & Release (2-3 weeks)

1. Performance benchmarking & optimization (1 week)
2. Demo game development (1 week)
3. Documentation & examples (1 week)
4. Release preparation (2-3 days)

**Total Estimated Time**: 20-29 weeks (~5-7 months)

---

## üéØ Milestones

### Milestone 1: Arrays & Loops ‚úÖ

**Target**: End of Week 4

- Arrays working
- For loops working
- ~30 new tests
- Updated examples

### Milestone 2: Match & Enums ‚úÖ

**Target**: End of Week 8

- Match expressions working
- Enums working
- State machine example
- ~30 new tests

### Milestone 3: Godot Features ‚úÖ

**Target**: End of Week 14

- Signals working
- New types working
- New callbacks working
- Updated Godot examples

### Milestone 4: LSP Alpha ‚úÖ

**Target**: End of Week 22

- Basic LSP working
- VS Code extension available
- Syntax errors in real-time

### Milestone 5: v0.1.0 Release ‚úÖ

**Target**: End of Week 25-29

- All features complete
- Demo game built
- Documentation complete
- Performance validated

---

## üö´ Explicitly Out of Scope for v0.1.0

**Language Features**:

- ‚ùå Macros
- ‚ùå Traits/interfaces
- ‚ùå Generics
- ‚ùå Async/await
- ‚ùå Unsafe blocks
- ‚ùå Modules/imports
- ‚ùå Package system

**Godot Features**:

- ‚ùå 3D support (save for v0.2.0+)
- ‚ùå Advanced physics
- ‚ùå Networking
- ‚ùå VR/AR
- ‚ùå Mobile-specific features
- ‚ùå Web export

**Tooling**:

- ‚ùå Full debugger (save for v0.2.0+)
- ‚ùå Profiler
- ‚ùå Package manager
- ‚ùå Build system (beyond Cargo)

---

## üìù Release Planning

### Pre-Release (v0.1.0-alpha, v0.1.0-beta)

Consider alpha/beta releases for early feedback:

- **v0.1.0-alpha.1**: After Milestone 2 (arrays, loops, match)
- **v0.1.0-alpha.2**: After Milestone 3 (Godot features)
- **v0.1.0-beta.1**: After Milestone 4 (LSP)
- **v0.1.0**: Final release after all testing

### v0.1.0 Release

- Tag: `v0.1.0`
- Full changelog
- Migration guide from v0.0.X
- Blog post/announcement
- Demo game showcase
- Video tutorial

---

## ü§ù Community & Contribution

### Governance

- Establish contribution guidelines for v0.1.0 development
- Create RFC (Request for Comments) process for major features
- Set up regular dev meetings/updates
- Create project board for tracking

### Collaboration

- Break features into small, contributor-friendly tasks
- Good first issue tags
- Mentor new contributors
- Recognize contributions

---

## üìö Documentation for v0.1.0

### New Documentation Needed

- [ ] Language reference (complete syntax guide)
- [ ] Godot integration guide (comprehensive)
- [ ] Tutorial series (beginner to advanced)
- [ ] API reference (auto-generated)
- [ ] Migration guide (v0.0.X ‚Üí v0.1.0)
- [ ] Performance guide
- [ ] LSP user guide

### Updated Documentation

- [ ] README (new features, examples)
- [ ] ARCHITECTURE (reflect new features)
- [ ] CONTRIBUTING (updated for v0.1.0 workflow)
- [ ] RELEASE_NOTES (complete v0.1.0 notes)

---

## üîÆ Looking Ahead to v0.2.0

**Potential Focus Areas**:

1. **3D Support**: Expand to 3D games
2. **Advanced Tooling**: Full debugger, profiler
3. **Performance**: Bytecode compilation, JIT
4. **Advanced Language Features**: Traits, generics
5. **Package System**: Import other FerrisScript libraries

**Target**: 6-12 months after v0.1.0

---

**Last Updated**: October 2025  
**Maintainer**: @dev-parkins  
**Status**: üü° Planning

---

**Note**: This roadmap is ambitious. Priorities may shift based on:

- Community feedback
- Technical challenges discovered
- Resource availability
- User adoption patterns

The goal is to make FerrisScript **practical and delightful** for Godot game development! ü¶ÄüéÆ
