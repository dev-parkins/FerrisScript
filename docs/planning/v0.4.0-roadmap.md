# FerrisScript v0.4.0 Roadmap (Proposed) 🦀

**Version**: 0.4.0 (Minor Release)  
**Status**: 📋 **PROPOSED** - Not yet scheduled  
**Target Date**: TBD (After v0.3.0)  
**Focus**: Documentation site, compiler warnings, and developer tooling enhancements

> ⚠️ **Note**: This roadmap is **PROPOSED** and subject to change based on v0.1.0, v0.2.0, and v0.3.0 outcomes, community feedback, and evolving priorities.

---

## 📋 Overview

**Semantic Versioning Context**:

- v0.X.0 = Minor releases (new features, backward compatible)
- v0.X.Y = Patch releases (bug fixes, documentation)

**v0.4.0 Vision**:
Establish FerrisScript as a professional, well-documented language with comprehensive tooling. Focus on developer experience through enhanced documentation, compiler intelligence, and ecosystem growth.

---

## 🎯 Core Goals

1. **Professional Documentation** 📚
   - Official documentation website
   - Comprehensive guides and tutorials
   - API reference documentation
   - Interactive examples

2. **Compiler Intelligence** 🧠
   - Static analysis and warnings
   - Overflow detection
   - Code suggestions and hints
   - Performance linting

3. **Syntax Highlighting Ecosystem** 🎨
   - GitHub Linguist support
   - Documentation site highlighting (Shiki)
   - Markdown code block support
   - Cross-platform consistency

4. **Developer Tooling** 🛠️
   - Enhanced LSP features
   - Debugging improvements
   - Performance profiling
   - Build system enhancements

---

## 📚 Documentation Site (HIGHEST PRIORITY)

> **Rationale**: Professional documentation is critical for adoption and community growth

### 1. Official Documentation Website

**Status**: 🔴 Not Started  
**Priority**: 🔥 **CRITICAL**  
**Rationale**: Central hub for learning, API reference, and community resources

**Recommended Tech Stack**:

- **VitePress** (Vue-based, modern, fast) - **Recommended**
- OR **Astro** (multi-framework, very modern)
- OR **Docusaurus** (React, Facebook's tool, battle-tested)

**Site Structure**:

```
ferrisscript.org/
├── guide/
│   ├── getting-started/
│   ├── basics/
│   ├── godot-integration/
│   └── advanced/
├── reference/
│   ├── language/
│   ├── standard-library/
│   └── godot-api/
├── examples/
│   ├── 2d-games/
│   ├── 3d-games/
│   └── patterns/
├── blog/
└── playground/ (stretch goal)
```

**Key Pages**:

- Home page with feature highlights
- Quick start guide (5-minute tutorial)
- Language reference (complete syntax)
- API documentation (standard library + Godot bindings)
- Examples gallery (with live code)
- Community resources (Discord, GitHub, etc.)

**Features**:

- Search functionality (Algolia or similar)
- Code examples with syntax highlighting
- Interactive playground (stretch goal)
- Dark/light theme
- Mobile-responsive design
- Versioned documentation (v0.1.0, v0.2.0, etc.)

**Tests**: Manual validation (navigation, search, mobile)  
**Estimated Effort**: 2-3 weeks

---

### 2. Shiki Syntax Highlighting Integration

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: Professional code highlighting in documentation

> **Research**: See `docs/planning/technical/MARKDOWN_SYNTAX_HIGHLIGHTING_RESEARCH.md` for detailed analysis

**Implementation**:

1. Install Shiki in documentation site
2. Configure to load FerrisScript TextMate grammar (from v0.1.0)
3. Test with various code examples
4. Verify theme compatibility (dark/light modes)
5. Optimize bundle size

**Example**:

```javascript
// vite.config.js (VitePress example)
import { defineConfig } from 'vitepress';
import { getHighlighter } from 'shiki';

export default defineConfig({
  markdown: {
    highlight: async (code, lang) => {
      const highlighter = await getHighlighter({
        themes: ['nord', 'min-light'],
        langs: [
          {
            id: 'ferrisscript',
            scopeName: 'source.ferrisscript',
            path: './ferrisscript.tmLanguage.json',  // Reuse VS Code grammar!
          }
        ]
      });
      return highlighter.codeToHtml(code, { lang, theme: 'nord' });
    }
  }
});
```

**Benefits**:

- ✅ Reuses VS Code TextMate grammar (zero duplication)
- ✅ Perfect consistency between editor and docs
- ✅ Supports multiple themes
- ✅ Very accurate highlighting

**Tests**: Visual validation across themes and examples  
**Estimated Effort**: 2 days

---

### 3. API Documentation Generator

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Auto-generate docs from code comments

**Options**:

- Custom tool (parse FerrisScript comments)
- Adapt existing tool (rustdoc-inspired)
- Manual documentation (interim solution)

**Documentation Comments**:

```rust
/// Adds two numbers together.
///
/// # Arguments
/// * `a` - First number
/// * `b` - Second number
///
/// # Returns
/// Sum of a and b
///
/// # Examples
/// ```ferrisscript
/// let result = add(5, 3);  // result = 8
/// ```
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

**Generated Output**:

- HTML pages for each function/type
- Search index for API reference
- Links between related items
- Code examples

**Tests**: Parser tests, output validation  
**Estimated Effort**: 1-2 weeks (custom tool) OR 3-5 days (manual)

**Recommendation**: Start with **manual documentation** in v0.4.0, build custom tool in v0.5.0+

---

### 4. Interactive Code Playground (Stretch Goal)

**Status**: 🔴 Not Started  
**Priority**: Low (Nice-to-have)  
**Rationale**: Let users try FerrisScript in browser without installation

**Tech Stack**:

- WebAssembly compilation of FerrisScript compiler
- Monaco Editor (VS Code's editor in browser)
- Syntax highlighting integration

**Features**:

- Edit FerrisScript code in browser
- Compile and show errors
- See generated bytecode (optional)
- Share code snippets (URLs)

**Challenges**:

- Compiling to WebAssembly (significant effort)
- No Godot integration (browser limitation)
- Security concerns (sandboxing)

**Recommendation**: **Defer to v0.5.0+** unless strong demand

**Estimated Effort**: 2-3 weeks (complex feature)

---

## 🎨 Syntax Highlighting Ecosystem (HIGH PRIORITY)

> **Research**: See `docs/planning/technical/MARKDOWN_SYNTAX_HIGHLIGHTING_RESEARCH.md` for comprehensive analysis

### 1. GitHub Linguist Submission

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: Enable syntax highlighting in GitHub markdown and repos

**Prerequisites**:

- [x] `.ferris` file extension established ✅
- [ ] Stable TextMate grammar (from v0.1.0) ⏳
- [ ] VS Code extension published ⏳
- [x] Sample FerrisScript code ✅
- [ ] Language relatively stable ⏳

**Implementation**:

1. **Package submission** (1-2 days):

   ```yaml
   # languages.yml
   FerrisScript:
     type: programming
     color: "#CE422B"  # Ferris-orange
     extensions:
     - ".ferris"
     tm_scope: source.ferrisscript
     ace_mode: rust  # Fallback mode
     language_id: 999999  # Unique ID (assigned by GitHub)
   ```

2. **Submit PR to GitHub Linguist**:
   - Include TextMate grammar
   - Add sample FerrisScript files
   - Link to project and community
   - Respond to maintainer feedback

3. **Update documentation** after merge:
   - Switch code blocks from `rust` to `ferrisscript`
   - Showcase syntax highlighting in README

**Benefits**:

- ✅ Official GitHub recognition
- ✅ Automatic syntax highlighting in repos
- ✅ Language statistics on GitHub
- ✅ Zero maintenance (GitHub handles it)

**Timeline**: 1-2 days (packaging) + 2-4 weeks (PR review)

**Tests**: Visual validation on GitHub after merge

**Reference**: https://github.com/github/linguist/blob/master/CONTRIBUTING.md

---

### 2. Markdown Documentation Standards

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Consistent code block usage across all documentation

**Standards Document**:

```markdown
# FerrisScript Markdown Guidelines

## Code Blocks

### For v0.4.0+ (After Linguist merge)
Use `ferrisscript` language tag:
\`\`\`ferrisscript
fn _ready() {
    print("Hello, Ferris!");
}
\`\`\`

### Before v0.4.0 (Fallback)
Use `rust` language tag with note:
\`\`\`rust
// FerrisScript code (using Rust highlighting)
fn _ready() {
    print("Hello, Ferris!");
}
\`\`\`

> **Note**: Currently using Rust syntax highlighting as approximation.
> Native FerrisScript highlighting coming in v0.4.0.
```

**Implementation**:

1. Create `MARKDOWN_GUIDELINES.md` in docs/
2. Update all existing markdown files
3. Add to contribution guide
4. Add to PR template

**Estimated Effort**: 1 day

---

## 🧠 Compiler Intelligence & Static Analysis (MEDIUM PRIORITY)

### 1. Overflow Detection Warnings

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Dependencies**: Dataflow analysis, LSP integration (v0.1.0)

**Features**:

```rust
// Warning: Potential overflow in constant expression
let big: i32 = 2000000000 + 2000000000;
//             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ overflow detected

// Suggestion: Use i64 or checked arithmetic
let safe: i64 = 2000000000_i64 + 2000000000_i64;
let checked: i32 = 2000000000_i32.checked_add(2000000000)?;
```

**Implementation**:

1. **Constant folding**: Detect literal overflow at compile time
2. **Range analysis**: Detect variable overflow potential
3. **Emit warnings**: Integrate with LSP diagnostics
4. **Suggest fixes**: Code actions for quick fixes

**LSP Integration**:

- Diagnostic messages with severity levels
- Code actions ("Convert to i64", "Use checked_add")
- Quick fixes in VS Code

**Tests**: Overflow detection tests, LSP diagnostic tests  
**Estimated Effort**: 1-2 weeks

---

### 2. Unused Variable/Function Warnings

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Help developers clean up code

**Examples**:

```rust
// Warning: Unused variable `x`
let x: i32 = 42;  // Never used

// Warning: Unused function `helper`
fn helper() {  // Never called
    print("Helper");
}

// Suppress warning with underscore prefix
let _ignored: i32 = 42;  // OK
```

**Implementation**:

1. Track variable/function usage in semantic analysis
2. Emit warnings for unused items
3. Support suppression (`_prefix` convention)
4. Integrate with LSP

**Tests**: Unused detection tests  
**Estimated Effort**: 3-5 days

---

### 3. Dead Code Elimination Warnings

**Status**: 🔴 Not Started  
**Priority**: Low  
**Rationale**: Identify unreachable code

**Examples**:

```rust
// Warning: Unreachable code
fn example() {
    return;
    print("Never executed");  // Warning: unreachable
}

// Warning: Dead branch
if true {
    print("Always executed");
} else {
    print("Never executed");  // Warning: dead code
}
```

**Implementation**:

1. Control flow graph analysis
2. Detect unreachable statements
3. Emit warnings
4. Integrate with LSP

**Tests**: Dead code detection tests  
**Estimated Effort**: 5-7 days

---

### 4. Type Inference Improvements

**Status**: 🔴 Not Started  
**Priority**: Low  
**Rationale**: Reduce explicit type annotations (where safe)

**Examples**:

```rust
// Current: Explicit type required
let position: Vector2 = Vector2 { x: 100.0, y: 200.0 };

// Improved: Type inferred from literal
let position = Vector2 { x: 100.0, y: 200.0 };  // Infers Vector2

// Function return type inference
fn get_position() -> Vector2 {  // Still explicit for function signatures
    Vector2 { x: 0.0, y: 0.0 }  // Infers return type
}
```

**Scope**:

- Infer types from literals and constructors
- Keep explicit types for function signatures
- Keep explicit types for globals
- Opt-in inference (don't force it)

**Tests**: Type inference tests  
**Estimated Effort**: 1-2 weeks (depends on scope)

**Recommendation**: **Defer to v0.5.0+** (not critical, adds complexity)

---

## 🛠️ Developer Tooling Enhancements (MEDIUM PRIORITY)

### 1. Enhanced LSP Features

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Dependencies**: v0.1.0 LSP foundation

**New Capabilities**:

- **Inlay hints**: Show inferred types inline
- **Semantic highlighting**: Color variables by mutability/scope
- **Symbol renaming**: Rename across files
- **Find all references**: Show all usages
- **Code lens**: Show function usage counts
- **Folding ranges**: Collapse code blocks

**Example (Inlay Hints)**:

```rust
// Without hints
let position = Vector2 { x: 100.0, y: 200.0 };

// With hints (shown in gray in editor)
let position: Vector2 = Vector2 { x: 100.0, y: 200.0 };
              ^^^^^^^^  // Inlay hint
```

**Tests**: LSP protocol tests  
**Estimated Effort**: 1-2 weeks

---

### 2. Debugger Integration (Stretch Goal)

**Status**: 🔴 Not Started  
**Priority**: Low  
**Rationale**: Step-through debugging in VS Code

**Features**:

- Set breakpoints in `.ferris` files
- Step through code execution
- Inspect variables
- View call stack
- Integration with Godot debugger

**Challenges**:

- Debug information generation
- Godot integration complexity
- Platform-specific debugging

**Recommendation**: **Defer to v0.5.0+** (complex, low priority)

**Estimated Effort**: 3-4 weeks (complex feature)

---

### 3. Performance Profiling (Stretch Goal)

**Status**: 🔴 Not Started  
**Priority**: Low  
**Rationale**: Identify performance bottlenecks

**Features**:

- Function execution time tracking
- Memory allocation tracking
- Hot path identification
- Integration with Godot profiler

**Recommendation**: **Defer to v0.6.0+** (not critical for v0.4.0)

**Estimated Effort**: 2-3 weeks

---

## 📊 Success Metrics

**Documentation Site**:

- Site launched and accessible
- All core guides published
- Search functionality working
- Mobile-responsive
- < 500ms page load time

**Syntax Highlighting**:

- GitHub Linguist PR merged
- Code blocks highlighted on GitHub
- Docs site highlighting working
- Consistency across platforms

**Compiler Intelligence**:

- Overflow warnings working
- Unused variable/function warnings
- LSP integration complete
- < 10% false positives

**Developer Tooling**:

- Enhanced LSP features working
- Positive community feedback
- Adoption by VS Code users

---

## 🚫 Explicitly Out of Scope

### Not in v0.4.0

1. **Interactive Playground** ❌
   - Complex WebAssembly compilation
   - Defer to v0.5.0+ if demand exists

2. **Debugger Integration** ❌
   - Too complex for v0.4.0
   - Defer to v0.5.0+

3. **API Documentation Generator** ❌
   - Start with manual docs
   - Build custom tool in v0.5.0+

4. **Performance Profiling** ❌
   - Not critical for v0.4.0
   - Defer to v0.6.0+

5. **Multi-Language Support (i18n)** ❌
   - Documentation site in English only
   - Consider in v1.0+

---

## 📝 Open Questions

1. **Which documentation site generator?**
   - VitePress (Vue, modern, fast) - **Recommended**
   - Astro (multi-framework, very modern)
   - Docusaurus (React, battle-tested)
   - **Decision**: Choose based on team preference and features

2. **Should we build API doc generator or start manual?**
   - Custom tool: 1-2 weeks effort
   - Manual docs: 3-5 days
   - **Recommendation**: Start manual, build tool in v0.5.0

3. **Should we defer GitHub Linguist to v0.1.0-v0.2.0 instead?**
   - Pro: Earlier GitHub support
   - Con: Language syntax might still change
   - **Recommendation**: v0.4.0 after language is stable

4. **What level of type inference should we support?**
   - Conservative: Only literals/constructors
   - Aggressive: Function bodies too
   - **Recommendation**: Conservative in v0.4.0, expand in v0.5.0

---

## 🗓️ Tentative Schedule

**Assumptions**: v0.3.0 complete, team of 1-2 developers

| Phase | Duration | Features |
|-------|----------|----------|
| **Design & Planning** | 1 week | Site architecture, content strategy |
| **Documentation Site** | 2-3 weeks | Build site, write guides, API docs |
| **Shiki Integration** | 2 days | Syntax highlighting setup |
| **GitHub Linguist** | 1 week | Package, submit, respond to feedback |
| **Compiler Warnings** | 1-2 weeks | Overflow detection, unused variables |
| **Enhanced LSP** | 1-2 weeks | Inlay hints, semantic highlighting |
| **Testing & Polish** | 1 week | Bug fixes, performance optimization |
| **Documentation** | 3-5 days | Release notes, migration guide |
| **Beta Testing** | 1 week | Community testing |
| **Release Prep** | 3-4 days | Final polish, launch |

**Total Estimated Time**: 9-12 weeks (~2-3 months)

---

## 📚 Related Documents

- [v0.1.0 Roadmap](v0.1.0-ROADMAP.md) - Godot release (LSP, tooling)
- [v0.2.0 Roadmap (Proposed)](v0.2.0-roadmap.md) - Extended type system
- [v0.3.0 Roadmap (Proposed)](v0.3.0-roadmap.md) - Arithmetic safety
- [Markdown Syntax Highlighting Research](technical/MARKDOWN_SYNTAX_HIGHLIGHTING_RESEARCH.md) - Detailed analysis
- [Type Promotion Research](technical/TYPE_PROMOTION_RESEARCH.md) - Type system design
- [Version Planning](VERSION_PLANNING.md) - Overall version strategy

---

## 🔗 References

**Documentation Tools**:

- VitePress: https://vitepress.dev/
- Astro: https://astro.build/
- Docusaurus: https://docusaurus.io/
- Shiki: https://shiki.matsu.io/

**Syntax Highlighting**:

- GitHub Linguist: https://github.com/github/linguist
- TextMate Grammars: https://macromates.com/manual/en/language_grammars

**Static Analysis**:

- Rust Clippy: https://github.com/rust-lang/rust-clippy (inspiration)
- TypeScript Compiler: https://github.com/microsoft/TypeScript (reference)

---

**Status**: 📋 **PROPOSED** - Awaiting v0.1.0, v0.2.0, and v0.3.0 completion

**Last Updated**: October 7, 2025
