# FerrisScript v0.3.0 Roadmap (Proposed) 🦀

**Version**: 0.3.0 (Minor Release)  
**Status**: 📋 **PROPOSED** - Not yet scheduled  
**Target Date**: TBD (After v0.2.0)  
**Focus**: Arithmetic safety and overflow protection

> ⚠️ **Note**: This roadmap is **PROPOSED** and subject to change based on v0.1.0 and v0.2.0 outcomes, community feedback, and evolving priorities.

---

## 📋 Overview

**Semantic Versioning Context**:

- v0.X.0 = Minor releases (new features, backward compatible)
- v0.X.Y = Patch releases (bug fixes, documentation)

**v0.3.0 Vision**:
Add optional arithmetic safety features to help developers write safer game logic. Focus on overflow protection without sacrificing performance in hot paths.

---

## 🎯 Core Goals

1. **Arithmetic Safety** 🛡️
   - Checked arithmetic methods (detect overflow)
   - Saturating arithmetic (clamp to min/max)
   - Wrapping arithmetic (explicit wrap behavior)
   - Overflowing arithmetic (return overflow flag)

2. **Developer Control** 🎮
   - Opt-in safety (no performance cost when unused)
   - Explicit method calls (clear intent)
   - Match Rust's approach (proven in production)

3. **Educational Value** 📚
   - Teach overflow awareness
   - Encourage safe practices
   - Differentiate from dynamic languages

4. **Integration** 🔗
   - Work with extended type system (v0.2.0)
   - Integrate with LSP (warnings/suggestions)
   - Support all numeric types

---

## 🛡️ Checked Arithmetic (HIGH PRIORITY)

> **Research**: See `docs/planning/technical/TYPE_PROMOTION_RESEARCH.md` for overflow strategies

### 1. Checked Methods (Returns Optional)

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: Detect overflow at runtime, return `None` if overflow occurs

**New Methods**:

```rust
// Addition
fn checked_add(self, rhs: Self) -> Option<Self>

// Subtraction
fn checked_sub(self, rhs: Self) -> Option<Self>

// Multiplication
fn checked_mul(self, rhs: Self) -> Option<Self>

// Division
fn checked_div(self, rhs: Self) -> Option<Self>

// Negation
fn checked_neg(self) -> Option<Self>

// Exponentiation
fn checked_pow(self, exp: u32) -> Option<Self>
```

**Example Usage**:

```rust
fn add_health(current: i32, amount: i32) -> i32 {
    // Safe addition with overflow detection
    match current.checked_add(amount) {
        Some(new_health) => new_health,
        None => {
            print("Warning: Health overflow, clamping to max");
            i32::MAX  // Fallback to max
        }
    }
}

// With error propagation (if FerrisScript gets `?` operator)
fn calculate_damage(base: i32, multiplier: i32) -> Option<i32> {
    let damage = base.checked_mul(multiplier)?;
    Some(damage)
}
```

**Implementation**:

1. Add `Option<T>` type to type system
2. Implement checked methods for all numeric types
3. Runtime overflow detection (CPU flags or software checks)
4. Return `None` on overflow
5. Add comprehensive tests (boundary values)

**Supported Types**:

- `i32`, `i64`, `i16`, `u8`, `u16`, `u32` (if added), `u64` (if added)
- Not needed for `f32`, `f64` (floats have Infinity/NaN)

**Tests**: ~30-40 new tests (all types × all operations)  
**Estimated Effort**: 1-2 weeks

---

### 2. Saturating Methods (Clamps to Min/Max)

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: Clamp results to type's min/max instead of wrapping

**New Methods**:

```rust
// Addition (clamps to MAX)
fn saturating_add(self, rhs: Self) -> Self

// Subtraction (clamps to MIN)
fn saturating_sub(self, rhs: Self) -> Self

// Multiplication (clamps to MAX/MIN)
fn saturating_mul(self, rhs: Self) -> Self

// Exponentiation (clamps to MAX)
fn saturating_pow(self, exp: u32) -> Self
```

**Example Usage**:

```rust
fn add_score(current: i32, points: i32) -> i32 {
    // Add points, but never overflow (clamps to i32::MAX)
    current.saturating_add(points)
}

fn apply_damage(health: i32, damage: i32) -> i32 {
    // Subtract damage, but never go below 0 (clamps to 0)
    health.saturating_sub(damage).max(0)
}

fn calculate_velocity(speed: i32, boost: i32) -> i32 {
    // Multiply, but clamp if too fast
    speed.saturating_mul(boost)
}
```

**Use Cases**:

- **Game health/mana**: Never overflow above max
- **Score systems**: Clamp to max score
- **Physics calculations**: Clamp velocity/force
- **Resource counters**: Clamp to limits

**Implementation**:

1. Implement saturating methods for all numeric types
2. Clamp to `Self::MIN` or `Self::MAX` on overflow
3. Add comprehensive tests

**Tests**: ~30-40 new tests  
**Estimated Effort**: 1 week

---

### 3. Wrapping Methods (Explicit Wrap)

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Explicitly document wrapping behavior (already default in release)

**New Methods**:

```rust
// Addition (wraps on overflow)
fn wrapping_add(self, rhs: Self) -> Self

// Subtraction (wraps on underflow)
fn wrapping_sub(self, rhs: Self) -> Self

// Multiplication (wraps on overflow)
fn wrapping_mul(self, rhs: Self) -> Self

// Negation (wraps at MIN)
fn wrapping_neg(self) -> Self
```

**Example Usage**:

```rust
fn update_frame_counter(current: u32) -> u32 {
    // Intentional wrap (cycles 0 → u32::MAX → 0)
    current.wrapping_add(1)
}

fn calculate_hash(value: i32, seed: i32) -> i32 {
    // Hash functions often rely on wrapping
    value.wrapping_mul(31).wrapping_add(seed)
}
```

**Use Cases**:

- **Frame counters**: Intentional wrapping
- **Hash functions**: Wrapping is expected
- **Cryptography**: Modular arithmetic
- **Low-level algorithms**: Explicit wrap behavior

**Implementation**:

1. Implement wrapping methods for all numeric types
2. Wrap at type boundaries (already default behavior)
3. Document wrapping as intentional

**Rationale**: Makes wrapping **explicit** in code (self-documenting)

**Tests**: ~20-25 new tests  
**Estimated Effort**: 3-4 days

---

### 4. Overflowing Methods (Returns Tuple)

**Status**: 🔴 Not Started  
**Priority**: Low  
**Rationale**: Return result + overflow flag (advanced use case)

**New Methods**:

```rust
// Returns (result, did_overflow)
fn overflowing_add(self, rhs: Self) -> (Self, bool)
fn overflowing_sub(self, rhs: Self) -> (Self, bool)
fn overflowing_mul(self, rhs: Self) -> (Self, bool)
fn overflowing_neg(self) -> (Self, bool)
```

**Example Usage**:

```rust
fn add_with_carry(a: i32, b: i32, carry: bool) -> (i32, bool) {
    let (sum, overflow1) = a.overflowing_add(b);
    let (final_sum, overflow2) = sum.overflowing_add(if carry { 1 } else { 0 });
    (final_sum, overflow1 || overflow2)
}
```

**Use Cases**:

- **Multi-precision arithmetic**: Building larger integers
- **Carry flags**: Emulating CPU arithmetic
- **Low-level algorithms**: Need overflow information

**Implementation**:

1. Return tuple: `(wrapped_result, did_overflow)`
2. Implement for all numeric types

**Tests**: ~15-20 new tests  
**Estimated Effort**: 2-3 days

---

## 📊 Type Constants (Supporting Feature)

### Min/Max Constants for All Types

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Enable boundary checks and clamping

**New Constants**:

```rust
// Integer types
i32::MIN    // -2147483648
i32::MAX    // 2147483647
i64::MIN    // -9223372036854775808
i64::MAX    // 9223372036854775807
u8::MIN     // 0
u8::MAX     // 255
// ... etc for all types

// Float types
f32::MIN          // Smallest finite value
f32::MAX          // Largest finite value
f32::INFINITY     // Positive infinity
f32::NEG_INFINITY // Negative infinity
f32::NAN          // Not a number
// ... etc for f64
```

**Example Usage**:

```rust
fn clamp_to_byte(value: i32) -> u8 {
    if value < u8::MIN as i32 {
        u8::MIN
    } else if value > u8::MAX as i32 {
        u8::MAX
    } else {
        value as u8
    }
}

fn is_valid_score(score: i32) -> bool {
    score >= 0 && score <= i32::MAX
}
```

**Implementation**:

1. Add constants to type system
2. Make available in all scopes
3. Document in language reference

**Tests**: ~10-12 new tests  
**Estimated Effort**: 1-2 days

---

## 🛠️ LSP Integration (Developer Experience)

### 1. Overflow Warnings

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Dependencies**: LSP (v0.1.0), dataflow analysis

**Features**:

```rust
// LSP warning: "Potential overflow in constant expression"
let big: i32 = 2000000000 + 2000000000;
//             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ overflow detected

// Suggestion: "Use checked_add() or i64 type"
let safe = 2000000000_i32.checked_add(2000000000)?;
let wide = 2000000000_i64 + 2000000000_i64;
```

**Implementation**:

1. Constant folding for literal overflow detection
2. Range analysis for variable overflow detection
3. Emit LSP warnings for potential overflows
4. Suggest fixes (checked methods, wider types)

**Tests**: LSP diagnostic tests  
**Estimated Effort**: 1-2 weeks (requires dataflow analysis)

---

### 2. Quick Fixes

**Status**: 🔴 Not Started  
**Priority**: Low  
**Dependencies**: LSP code actions

**Features**:

- Quick fix: Convert `+` to `.checked_add()`
- Quick fix: Convert `i32` to `i64`
- Quick fix: Add `.saturating_add()` for clamping

**Example**:

```rust
// User writes:
let result = a + b;  // Warning: potential overflow

// LSP offers quick fixes:
// 1. Use checked_add(): a.checked_add(b)?
// 2. Use saturating_add(): a.saturating_add(b)
// 3. Widen types: (a as i64) + (b as i64)
```

**Tests**: LSP code action tests  
**Estimated Effort**: 3-5 days

---

## 📚 Documentation & Education

### 1. Overflow Guide

**Status**: 🔴 Not Started  
**Priority**: High  
**Content**:

- What is integer overflow?
- Why does it matter?
- When to use each method
- Performance implications
- Examples from real games

**Location**: `docs/guides/overflow-safety.md`  
**Estimated Effort**: 2-3 days

---

### 2. API Documentation

**Status**: 🔴 Not Started  
**Priority**: High  
**Content**:

- Document all checked/saturating/wrapping methods
- Add examples for each method
- Explain return types (Option, tuple)

**Location**: Language reference  
**Estimated Effort**: 2-3 days

---

## 📊 Success Metrics

**Safety Adoption**:

- % of projects using checked arithmetic
- Reported overflow bugs (should decrease)
- Community feedback on safety features

**Developer Experience**:

- LSP warning effectiveness
- Quick fix usage statistics
- Documentation clarity (feedback)

**Performance**:

- No performance regression for unchecked code
- Checked methods only add cost when used

---

## 🚫 Explicitly Out of Scope

### Not in v0.3.0

1. **Automatic Overflow Detection** ❌
   - No automatic insertion of checks
   - Opt-in only (explicit method calls)
   - Reason: Performance, predictability

2. **Compiler Flags for Overflow Behavior** ❌
   - No global "panic on overflow" flag
   - Reason: Use checked methods instead
   - Deferred to v0.4.0+ if requested

3. **Arbitrary-Precision Integers** ❌
   - No BigInt type
   - Reason: Performance, complexity
   - Deferred to v1.0+ if requested

4. **Fixed-Point Arithmetic** ❌
   - No fixed-point number types
   - Reason: Use f32/f64 or custom library
   - Deferred indefinitely

---

## 📝 Open Questions

1. **Should we add a `Result<T, E>` type** for better error handling?
   - Checked methods currently return `Option<T>`
   - `Result<T, OverflowError>` provides more context
   - **Decision**: Consider for v0.4.0

2. **Should overflow panic in debug builds** (like Rust)?
   - Rust: Panic in debug, wrap in release
   - FerrisScript: Currently wraps always
   - **Decision**: Match Rust behavior (breaking change, needs migration guide)

3. **Should we add overflow warnings** for non-constant expressions?
   - Requires dataflow analysis (complex)
   - May have false positives
   - **Decision**: Start with constant expressions, expand later

4. **Should we provide `#[overflow_checks(on/off)]`** attribute?
   - Per-function overflow checking
   - Adds complexity
   - **Decision**: Defer to v0.4.0+

---

## 🗓️ Tentative Schedule

**Assumptions**: v0.2.0 complete, team of 1-2 developers

| Phase | Duration | Features |
|-------|----------|----------|
| **Design & Spec** | 3-4 days | Finalize API, community feedback |
| **Checked Methods** | 1-2 weeks | Implement all checked_* methods |
| **Saturating Methods** | 1 week | Implement all saturating_* methods |
| **Wrapping Methods** | 3-4 days | Implement all wrapping_* methods |
| **Overflowing Methods** | 2-3 days | Implement all overflowing_* methods |
| **Type Constants** | 1-2 days | Add MIN/MAX constants |
| **LSP Integration** | 1-2 weeks | Overflow warnings, quick fixes |
| **Documentation** | 3-5 days | Overflow guide, API docs |
| **Testing** | 1 week | Comprehensive tests (150+ tests) |
| **Beta Testing** | 1 week | Community testing, bug fixes |
| **Release Prep** | 3-4 days | Release notes, migration guide |

**Total Estimated Time**: 6-8 weeks (~1.5-2 months)

---

## 📚 Related Documents

- [v0.1.0 Roadmap](v0.1.0-ROADMAP.md) - Godot release (LSP, tooling)
- [v0.2.0 Roadmap (Proposed)](v0.2.0-roadmap.md) - Extended type system
- [v0.4.0 Roadmap (Proposed)](v0.4.0-roadmap.md) - Compiler warnings (future)
- [Type Promotion Research](technical/TYPE_PROMOTION_RESEARCH.md) - Overflow strategies
- [Version Planning](VERSION_PLANNING.md) - Overall version strategy

---

## 🔗 References

**Rust Documentation**:

- Checked arithmetic: https://doc.rust-lang.org/std/primitive.i32.html#method.checked_add
- Overflow behavior: https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow

**Academic Papers**:

- Safe integer arithmetic: https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#integer-overflow

---

**Status**: 📋 **PROPOSED** - Awaiting v0.1.0 and v0.2.0 completion

**Last Updated**: October 7, 2025
