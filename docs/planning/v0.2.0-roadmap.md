# FerrisScript v0.2.0 Roadmap (Proposed) ü¶Ä

**Version**: 0.2.0 (Minor Release)  
**Status**: üìã **PROPOSED** - Not yet scheduled  
**Target Date**: TBD (After v0.1.0)  
**Focus**: Extended type system and language enhancements

> ‚ö†Ô∏è **Note**: This roadmap is **PROPOSED** and subject to change based on v0.1.0 outcomes, community feedback, and evolving priorities. Features may be moved, modified, or deferred.

---

## üìã Overview

**Semantic Versioning Context**:

- v0.X.0 = Minor releases (new features, backward compatible)
- v0.X.Y = Patch releases (bug fixes, documentation)

**v0.2.0 Vision**:
Expand FerrisScript's type system and language capabilities to support more complex game development scenarios. Focus on developer productivity enhancements that were deferred from v0.1.0.

---

## üéØ Core Goals

1. **Extended Type System** üî¢
   - Add 64-bit types for large values (timestamps, IDs)
   - Add smaller types for memory optimization (colors, tiles)
   - Maintain explicit type control (no automatic promotion)

2. **Language Feature Completion** ‚ú®
   - Features deferred from v0.1.0 (if not shipped)
   - Additional control flow constructs
   - Enhanced string handling

3. **Developer Experience** üõ†Ô∏è
   - Improved LSP capabilities
   - Better error recovery
   - Enhanced debugging support

4. **Performance Optimizations** ‚ö°
   - Runtime optimizations
   - Compilation speed improvements
   - Memory usage optimizations

---

## üî¢ Extended Type System (HIGH PRIORITY)

> **Research**: See `docs/planning/technical/TYPE_PROMOTION_RESEARCH.md` for detailed analysis

### 1. 64-bit Numeric Types

**Status**: üî¥ Not Started  
**Priority**: High  
**Rationale**: Enable large values (timestamps, entity IDs) and high-precision calculations

**New Types**:

```rust
i64  // 64-bit signed integer (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807)
f64  // 64-bit double-precision float (IEEE 754)
```

**Use Cases**:

- **Timestamps**: System time, game time (milliseconds)
- **Entity IDs**: Large-scale multiplayer games
- **Large coordinates**: Procedural worlds, space games
- **High-precision physics**: Scientific simulations

**Example**:

```rust
// Timestamps
let start_time: i64 = get_ticks_msec();  // Returns i64 from Godot

// Large entity IDs
let entity_id: i64 = 9999999999;

// High-precision calculations
let precise: f64 = 3.141592653589793;
```

**Implementation**:

1. Add `i64`, `f64` to lexer/parser
2. Update type checker for new types
3. Update runtime representation (FFI to Godot)
4. Add explicit casting: `value as i64`
5. Update Godot bindings (safe widening from i32‚Üíi64, f32‚Üíf64)
6. Add comprehensive tests

**Godot Compatibility**:

- ‚úÖ i32 ‚Üí i64 (Godot uses i64 internally): Safe widening
- ‚úÖ f32 ‚Üí f64 (Godot uses f64 internally): Safe widening
- ‚úÖ No breaking changes (all conversions safe)

**Tests**: ~15-20 new tests  
**Estimated Effort**: 1-2 weeks

---

### 2. Smaller Integer Types

**Status**: üî¥ Not Started  
**Priority**: Medium  
**Rationale**: Memory optimization for specific use cases (colors, tiles, compact data structures)

**New Types**:

```rust
i16  // 16-bit signed integer (-32,768 to 32,767)
u8   // 8-bit unsigned integer (0 to 255)
u16  // 16-bit unsigned integer (0 to 65,535)
```

**Use Cases**:

- **Colors**: `u8` for RGBA channels (0-255)
- **Tile coordinates**: `i16` for grid positions (-32K to +32K)
- **Small enums/flags**: `u8` for state machines
- **Audio samples**: `i16` for PCM audio data
- **Network packets**: Compact serialization

**Example**:

```rust
// Color channels
let red: u8 = 255;
let green: u8 = 128;
let blue: u8 = 0;
let alpha: u8 = 255;

// Tile coordinates (16-bit grid)
let tile_x: i16 = -1024;
let tile_y: i16 = 2048;

// Compact state
let player_state: u8 = 1;  // 0=idle, 1=running, 2=jumping
```

**Implementation**:

1. Add `i16`, `u8`, `u16` to lexer/parser
2. Update type checker for new types
3. Update runtime representation
4. Add explicit casting with overflow checks
5. Update Godot bindings (widen to i64 for Godot API)
6. Add comprehensive tests (especially overflow scenarios)

**Overflow Considerations**:

- Smaller types have higher overflow risk
- Debug builds: Panic on overflow (Rust default)
- Release builds: Wrap on overflow (Rust default)
- Future (v0.3.0): Add checked arithmetic methods

**Tests**: ~12-15 new tests  
**Estimated Effort**: 1 week

---

### 3. Explicit Type Casting

**Status**: üî¥ Not Started  
**Priority**: High  
**Rationale**: Enable safe conversions between numeric types

**Syntax**:

```rust
// Widening (always safe)
let small: i32 = 42;
let big: i64 = small as i64;

// Narrowing (may lose data, requires explicit cast)
let large: i64 = 1000000;
let narrow: i32 = large as i32;  // Truncates if too large

// Float conversions
let int_val: i32 = 42;
let float_val: f32 = int_val as f32;
let back_to_int: i32 = float_val as i32;  // Truncates decimal
```

**Casting Rules**:

1. **Widening conversions** (safe): No data loss
   - `i32 ‚Üí i64`, `i16 ‚Üí i32`, `u8 ‚Üí i32`
   - `f32 ‚Üí f64`

2. **Narrowing conversions** (unsafe): May lose data
   - `i64 ‚Üí i32` (truncates high bits)
   - `f64 ‚Üí f32` (loses precision)
   - `i32 ‚Üí i16`, `i32 ‚Üí u8` (truncates)

3. **Float ‚Üî Integer**: Truncates decimal part

**Compiler Behavior**:

- Explicit `as` cast required (no implicit conversions)
- Compiler warns on narrowing conversions (future)
- Runtime behavior matches Rust (wrapping/truncation)

**Tests**: ~20-25 new tests (comprehensive casting matrix)  
**Estimated Effort**: 3-4 days

---

### 4. Unsigned 32-bit/64-bit Types (Optional)

**Status**: üî¥ Not Started  
**Priority**: Low  
**Rationale**: Completeness, bit manipulation, specific algorithms

**New Types**:

```rust
u32  // 32-bit unsigned integer (0 to 4,294,967,295)
u64  // 64-bit unsigned integer (0 to 18,446,744,073,709,551,615)
```

**Use Cases**:

- **Bit manipulation**: Flags, bitmasks
- **Hashing**: Hash values (always positive)
- **Large IDs**: Entity IDs, UUIDs
- **Memory addresses**: Low-level operations

**Considerations**:

- Godot doesn't use unsigned extensively
- Adds complexity (signed/unsigned mixing)
- Overflow behavior differs from signed

**Decision**: Defer unless strong user demand

---

## ‚ú® Language Features (Deferred from v0.1.0)

### 1. Arrays/Lists (if not in v0.1.0)

**Status**: üî¥ Not Started (may ship in v0.1.0)  
**Priority**: High (if deferred)

See `docs/planning/v0.1.0-ROADMAP.md` for full specification.

**Note**: If shipped in v0.1.0, this section can be removed.

---

### 2. For Loops (if not in v0.1.0)

**Status**: üî¥ Not Started (may ship in v0.1.0)  
**Priority**: High (if deferred)

See `docs/planning/v0.1.0-ROADMAP.md` for full specification.

**Note**: If shipped in v0.1.0, this section can be removed.

---

### 3. Enhanced String Operations

**Status**: üî¥ Not Started  
**Priority**: Medium  
**Rationale**: Improve string handling for UI, localization, and text processing

**New Features**:

```rust
// String methods
let text: String = "Hello, World!";
let upper: String = text.to_uppercase();    // "HELLO, WORLD!"
let lower: String = text.to_lowercase();    // "hello, world!"
let trimmed: String = text.trim();          // Remove whitespace
let contains: bool = text.contains("World"); // true

// String slicing
let slice: String = text.substring(0, 5);   // "Hello"

// String formatting (if not in v0.1.0)
let formatted: String = format!("Score: {}", score);
```

**Implementation**:

1. Add string methods to runtime
2. Bind to Godot's String methods
3. Add string slicing syntax
4. Update type checker for string operations

**Tests**: ~10-12 new tests  
**Estimated Effort**: 3-4 days

---

## üõ†Ô∏è Developer Experience Enhancements

### 1. Enhanced LSP Features

**Status**: üî¥ Not Started  
**Priority**: Medium  
**Dependencies**: v0.1.0 LSP foundation

**New Capabilities**:

- Code actions (refactorings)
- Symbol renaming
- Find all references
- Inlay hints (type annotations)
- Semantic highlighting

**Tests**: LSP protocol tests  
**Estimated Effort**: 1-2 weeks

---

### 2. Improved Error Recovery

**Status**: üî¥ Not Started  
**Priority**: Medium  
**Rationale**: Better editing experience with partial/invalid code

**Enhancements**:

- Continue parsing after syntax errors
- Provide partial semantic information
- Better error suggestions

**Tests**: Error recovery tests  
**Estimated Effort**: 1 week

---

## üìä Success Metrics

**Type System Adoption**:

- % of projects using 64-bit types
- % of projects using smaller types (u8, i16)
- Reported overflow bugs (should decrease)

**Developer Experience**:

- LSP feature usage statistics
- Error recovery effectiveness
- Compilation speed improvements

**Community Feedback**:

- Feature requests addressed
- User satisfaction surveys
- GitHub issues/discussions

---

## üö´ Explicitly Out of Scope

### Not in v0.2.0

1. **Automatic Type Promotion** ‚ùå
   - Not aligned with explicit design philosophy
   - See TYPE_PROMOTION_RESEARCH.md for rationale
   - Deferred to v1.0+ (if ever)

2. **Checked Arithmetic Methods** ‚ùå
   - Deferred to v0.3.0 (see `v0.3.0-roadmap.md`)
   - Requires extended type system first

3. **Generics/Templates** ‚ùå
   - Too complex for v0.2.0
   - Consider for v0.5.0+

4. **Async/Await** ‚ùå
   - Not needed for Godot scripting
   - Deferred indefinitely

---

## üìù Open Questions

1. **Should we add unsigned 32/64-bit types** (`u32`, `u64`)?
   - Pros: Completeness, bit manipulation
   - Cons: Adds complexity, limited Godot use
   - **Decision**: Defer unless user demand

2. **Should overflow panic in release builds**?
   - Rust defaults to wrapping (performance)
   - Games may prefer deterministic behavior
   - **Decision**: Follow Rust defaults, make configurable later

3. **Should we support type inference for literals**?
   - `let x = 42` ‚Üí infer `i32` or `i64`?
   - **Decision**: Default to `i32` (matches current behavior)

4. **How to handle mixed-type arithmetic**?
   - `i32 + i64` ‚Üí error or auto-promote?
   - **Decision**: Require explicit cast (matches Rust)

---

## üóìÔ∏è Tentative Schedule

**Assumptions**: v0.1.0 complete, team of 1-2 developers

| Phase | Duration | Features |
|-------|----------|----------|
| **Design & Spec** | 1 week | Finalize type system spec, community feedback |
| **Core Types** | 2 weeks | Implement i64, f64, i16, u8, u16 |
| **Type Casting** | 1 week | Explicit casting, overflow handling |
| **Language Features** | 2 weeks | String operations, any deferred v0.1.0 features |
| **LSP Enhancements** | 1-2 weeks | Enhanced LSP features |
| **Testing & Docs** | 1 week | Comprehensive tests, documentation |
| **Beta Testing** | 1 week | Community testing, bug fixes |
| **Release Prep** | 1 week | Release notes, migration guide |

**Total Estimated Time**: 10-11 weeks (~2.5 months)

---

## üìö Related Documents

- [v0.1.0 Roadmap](v0.1.0-ROADMAP.md) - Current release
- [v0.3.0 Roadmap (Proposed)](v0.3.0-roadmap.md) - Checked arithmetic
- [Type Promotion Research](technical/TYPE_PROMOTION_RESEARCH.md) - Design rationale
- [Version Planning](VERSION_PLANNING.md) - Overall version strategy

---

**Status**: üìã **PROPOSED** - Awaiting v0.1.0 completion and community feedback

**Last Updated**: October 7, 2025
