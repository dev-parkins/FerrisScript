# FerrisScript v0.1.0 Roadmap 🦀

**Version**: 0.1.0 (Minor Release)  
**Target Date**: TBD (After v0.0.2-v0.0.X)  
**Focus**: New language features, enhanced Godot integration

> 📝 **Document Purpose**: This is the comprehensive **feature specification** for v0.1.0, detailing what features will be implemented and how they work. For the final release **execution plan** and integration deliverables, see [`docs/planning/v0.1.0-release-plan.md`](planning/v0.1.0-release-plan.md).

---

## 📋 Overview

**Semantic Versioning Context**:

- v0.0.X = Patch releases (bug fixes, documentation)
- v0.X.0 = **Minor releases** (new features, backward compatible)
- vX.0.0 = Major releases (breaking changes)

**v0.1.0 Vision**:
Transform FerrisScript from a proof-of-concept to a **practical scripting language** for Godot game development. Focus on features that enable real game development workflows.

**🔄 Strategic Prioritization Update**:
This roadmap has been revised to prioritize **editor integration and Godot API coverage** over advanced language features. While arrays and for loops remain important, **seamless usability and engine feature parity** are now the highest priorities to accelerate adoption and enable productive workflows from day one.

---

## 🎯 Core Goals

1. **Accelerate usability and adoption** ⚡
   - Prioritize editor integration for first-class scripting experience
   - Expand Godot API coverage for real-world game development
   - Improve error reporting and developer experience
   - Enable developers to be productive immediately

2. **Make FerrisScript usable for simple 2D games**
   - Support essential Godot types and API coverage
   - Enable basic game logic implementation
   - Enable common game patterns (arrays, loops, collections) - in parallel

3. **Improve developer experience**
   - Add tooling (LSP, syntax highlighting, snippets) - **HIGHEST PRIORITY**
   - Better error messages and diagnostics
   - Faster iteration with hot reload

4. **Validate architecture**
   - Ensure design scales to more features
   - Identify pain points early
   - Set foundation for v0.2.0+

### 📌 Strategic Shift

**Rationale for Prioritization**: While arrays and for loops are important language features, **seamless usability and engine feature parity** should be addressed in parallel for maximum impact and adoption. Developers need excellent tooling and comprehensive Godot integration to be productive, even with basic language features. This approach:

- **Accelerates adoption** by providing first-class editor support from day one
- **Enables real-world projects** with expanded Godot API coverage (signals, callbacks, types)
- **Reduces friction** through improved error reporting and diagnostics
- **Ships value incrementally** through frequent minor releases
- **Engages community** through better onboarding and documentation

---

## 🛠️ Tooling & Editor Integration (HIGHEST PRIORITY)

> **Strategic Focus**: Editor integration and developer experience are now the highest priority to accelerate adoption and enable productive workflows from day one.

### Critical Priority (Blocking for v0.1.0)

#### 1. Language Server Protocol (LSP)

**Status**: 🔴 Not Started  
**Priority**: 🔥 **CRITICAL**  
**Rationale**: Makes FerrisScript a real development language with first-class editor support

**Scope**:

- [ ] Basic LSP server implementation
- [ ] Syntax checking (real-time errors)
- [ ] Autocomplete (keywords, variables, functions)
- [ ] Go to definition
- [ ] Hover documentation
- [ ] VS Code extension

**Features**:

- Syntax errors as you type
- Autocomplete for variables, functions, types
- Jump to function definition
- Show type on hover

**Tests**: LSP protocol tests
**Estimated Effort**: 10-15 days (major feature)

---

#### 2. Syntax Highlighting & Editor Support

**Status**: � In Progress (v0.0.2 - Next Workstream)  
**Priority**: 🔥 **CRITICAL**  
**Rationale**: Basic developer experience requirement

**Scope**:

- [ ] TextMate grammar for VS Code
- [ ] Syntax highlighting for `.ferris` files
- [ ] Code snippets (fn, let, if, etc.)
- [ ] File icon for `.ferris` files
- [ ] Extension marketplace publishing

**Example Snippets**:

```json
{
  "ready": {
    "prefix": "_ready",
    "body": ["fn _ready() {", "\t$0", "}"]
  }
}
```

**Tests**: Manual validation in VS Code
**Estimated Effort**: 2-3 days

---

#### 3. Improved Error Messages

**Status**: � Partially Complete (v0.0.2 - Phase 2 & 3)  
**Priority**: 🔥 **CRITICAL**  
**Rationale**: Essential for debugging and learning the language

**Completed in v0.0.2** ✅:

- [x] Show source code context in errors (±2 lines with visual indicators)
- [x] Better error messages with line numbers and context
- [x] Helpful hints in all error messages
- [x] 17 new tests validating error messages
- [x] Improved type error messages

**Remaining for v0.1.0**:

- [ ] Colorized error output
- [ ] Suggest fixes ("did you mean `velocity`?")
- [ ] Error codes (E001, E002, etc.)
- [ ] Link to documentation for errors
- [ ] Integration with LSP for in-editor diagnostics

**Before**:

```
Error: Undefined variable: velocty
```

**After**:

```
Error[E101]: Undefined variable
  --> move.ferris:5:10
   |
 5 |     self.velocty.x += 50.0;
   |          ^^^^^^^ not found in this scope
   |
help: a local variable with a similar name exists
   |
 5 |     self.velocity.x += 50.0;
   |          ^^^^^^^^
```

**Tests**: Error message tests
**Estimated Effort**: 5-7 days

---

## 🎮 Enhanced Godot Integration (HIGH PRIORITY)

> **Strategic Focus**: Expanded Godot API coverage is critical for enabling real 2D game development before adding advanced language features.

### High Priority (Must-Have for v0.1.0)

#### 1. Signal Support

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: Core Godot feature for event-driven programming - essential for real games

**Scope**:

- [ ] Define signals in scripts
- [ ] Emit signals
- [ ] Connect to signals (from Godot)
- [ ] Signal with parameters

**Example**:

```rust
signal health_changed(old: i32, new: i32);

let mut health: i32 = 100;

fn take_damage(amount: i32) {
    let old_health: i32 = health;
    health -= amount;
    emit_signal("health_changed", old_health, health);
}
```

**Tests**: ~10-12 new tests
**Estimated Effort**: 5-7 days

---

#### 2. Additional Godot Types

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: Essential for 2D game development (colors, rectangles, transforms)

**New Types to Add**:

- [ ] `Color` - RGBA colors
- [ ] `Rect2` - 2D rectangles
- [ ] `Transform2D` - 2D transformations
- [ ] `Vector3` - 3D vectors (for future 3D support)
- [ ] `Basis` - 3D rotation
- [ ] `AABB` - Axis-aligned bounding box

**Example**:

```rust
fn _ready() {
    let red: Color = Color { r: 1.0, g: 0.0, b: 0.0, a: 1.0 };
    self.modulate = red;
    
    let bounds: Rect2 = Rect2 {
        position: Vector2 { x: 0.0, y: 0.0 },
        size: Vector2 { x: 100.0, y: 100.0 }
    };
}
```

**Tests**: ~20-25 new tests
**Estimated Effort**: 3-4 days

---

#### 3. Additional Callbacks

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: Enable input handling and physics - essential for interactive games

**New Callbacks**:

- [ ] `_input(event: InputEvent)` - Input handling
- [ ] `_physics_process(delta: f32)` - Physics updates
- [ ] `_enter_tree()` - Node enters scene tree
- [ ] `_exit_tree()` - Node exits scene tree
- [ ] `_draw()` - Custom drawing (2D)

**Example**:

```rust
fn _input(event: InputEvent) {
    if event.is_action_pressed("jump") {
        velocity.y = -300.0;
    }
}

fn _physics_process(delta: f32) {
    // Physics code here (fixed timestep)
}
```

**Tests**: ~8-10 new tests
**Estimated Effort**: 3-4 days

---

#### 4. Node Query Functions

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: Essential for interacting with scene tree - blocking for real games

**New Functions**:

- [ ] `get_node(path: String) -> Node`
- [ ] `find_child(name: String) -> Node`
- [ ] `get_parent() -> Node`
- [ ] `get_children() -> [Node]`
- [ ] `has_node(path: String) -> bool`

**Example**:

```rust
fn _ready() {
    let player: Node = get_node("../Player");
    let parent: Node = get_parent();
    
    if has_node("Enemy") {
        print("Enemy found!");
    }
}
```

**Tests**: ~10-12 new tests
**Estimated Effort**: 3-4 days

---

## ✨ Core Language Features (MEDIUM PRIORITY)

> **Strategic Shift**: Language features like arrays and loops remain important but are now medium priority. The focus is on usability and API coverage first, with language features added in parallel.

### Medium Priority (Nice-to-Have for v0.1.0)

#### 1. Array/List Types

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Important for game development but not blocking basic functionality

**Scope**:

- [ ] Array type syntax: `[i32]`, `[String]`, etc.
- [ ] Array literals: `[1, 2, 3]`
- [ ] Indexing: `arr[0]`, `arr[i]`
- [ ] Length: `arr.len()`
- [ ] Push/pop operations: `arr.push(5)`, `arr.pop()`
- [ ] Array methods: `contains()`, `clear()`, `remove_at()`
- [ ] Type checking for homogeneous arrays
- [ ] Integration with Godot Array type

**Example**:

```rust
let mut enemies: [Node] = [];

fn _ready() {
    enemies.push(get_node("Enemy1"));
    enemies.push(get_node("Enemy2"));
    print(enemies.len()); // 2
}

fn _process(delta: f32) {
    let mut i: i32 = 0;
    while i < enemies.len() {
        // Process each enemy
        i += 1;
    }
}
```

**Tests**: ~15-20 new tests
**Estimated Effort**: 5-7 days

---

#### 2. For Loops

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Nice to have but while loops provide this functionality already

**Scope**:

- [ ] Range syntax: `for i in 0..10`
- [ ] Array iteration: `for enemy in enemies`
- [ ] Inclusive ranges: `for i in 0..=10`
- [ ] Break statement
- [ ] Continue statement
- [ ] Nested loops

**Example**:

```rust
fn _process(delta: f32) {
    // Range loop
    for i in 0..10 {
        print(i);
    }
    
    // Array iteration
    for enemy in enemies {
        enemy.position.x += 10.0;
    }
}
```

**Tests**: ~10-15 new tests
**Estimated Effort**: 3-5 days

---

#### 3. Match Expressions

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Valuable feature but can use if/else for state machines initially

**Scope**:

- [ ] Match on integers: `match x { 1 => ..., 2 => ..., _ => ... }`
- [ ] Match on booleans
- [ ] Match on strings
- [ ] Exhaustiveness checking
- [ ] Match guards (if needed)
- [ ] Match with blocks

**Example**:

```rust
let mut state: String = "idle";

fn _process(delta: f32) {
    match state {
        "idle" => {
            // Idle behavior
        },
        "walking" => {
            self.position.x += 50.0 * delta;
        },
        "jumping" => {
            self.position.y -= 100.0 * delta;
        },
        _ => {
            print("Unknown state!");
        }
    }
}
```

**Tests**: ~15-20 new tests
**Estimated Effort**: 5-7 days

---

#### 4. String Interpolation

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Much nicer than string concatenation

**Scope**:

- [ ] Format string syntax: `f"Hello, {name}!"`
- [ ] Expression interpolation: `f"Score: {score * 10}"`
- [ ] Type conversion (int/float to string)
- [ ] Escape sequences

**Example**:

```rust
let name: String = "Player";
let score: i32 = 100;

fn _ready() {
    print(f"Hello, {name}! Your score is {score}.");
    print(f"Double score: {score * 2}");
}
```

**Tests**: ~8-10 new tests
**Estimated Effort**: 2-3 days

---

### Low Priority (Consider for v0.1.0)

#### 5. Enum Types

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Great for state machines, directions, etc.

**Scope**:

- [ ] Enum definition: `enum State { Idle, Walking, Jumping }`
- [ ] Enum values: `State::Idle`
- [ ] Match on enums (combines with #3)
- [ ] Type checking

**Example**:

```rust
enum Direction {
    Up,
    Down,
    Left,
    Right
}

let dir: Direction = Direction::Right;

fn _process(delta: f32) {
    match dir {
        Direction::Up => self.position.y -= 50.0 * delta,
        Direction::Down => self.position.y += 50.0 * delta,
        Direction::Left => self.position.x -= 50.0 * delta,
        Direction::Right => self.position.x += 50.0 * delta,
    }
}
```

**Tests**: ~12-15 new tests
**Estimated Effort**: 4-5 days

---

#### 6. Struct Types

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Custom data types for game entities

**Scope**:

- [ ] Struct definition: `struct Player { health: i32, mana: i32 }`
- [ ] Struct instantiation: `Player { health: 100, mana: 50 }`
- [ ] Field access: `player.health`
- [ ] Methods (later, for v0.2.0)

**Example**:

```rust
struct Player {
    health: i32,
    mana: i32,
    level: i32
}

let mut player: Player = Player {
    health: 100,
    mana: 50,
    level: 1
};

fn _process(delta: f32) {
    if player.health <= 0 {
        print("Game Over!");
    }
}
```

**Tests**: ~10-12 new tests
**Estimated Effort**: 5-6 days

---

### Low Priority (Consider for v0.2.0)

- [ ] Dictionary/HashMap types
- [ ] Tuple types
- [ ] Pattern matching (destructuring)
- [ ] Method calls on types
- [ ] Trait system (way future)
- [ ] Generics (way future)

---

### Low Priority (v0.2.0+)

- [ ] Resource loading (load scenes, textures, etc.)
- [ ] Timer nodes
- [ ] Tween/animation support
- [ ] 3D support (Camera3D, MeshInstance3D, etc.)
- [ ] Advanced physics (RigidBody2D, CollisionShape2D)
- [ ] Particle systems
- [ ] Audio playback

---

## 📚 Enhanced Onboarding & Documentation (HIGH PRIORITY)

> **Strategic Focus**: Excellent documentation and examples are critical for adoption and community growth.

### Documentation Priorities

#### 1. Getting Started Guide

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: First impression matters - make it easy for new users

**Scope**:

- [ ] Quick start tutorial (5-10 minutes to first script)
- [ ] Step-by-step Godot integration guide
- [ ] Common pitfalls and troubleshooting
- [ ] Video walkthrough
- [ ] Interactive examples

**Estimated Effort**: 3-4 days

---

#### 2. Example Projects

**Status**: 🔴 Not Started  
**Priority**: High  
**Rationale**: Learning by example is most effective

**Scope**:

- [ ] Simple examples (10+ scripts)
  - Hello World
  - Player movement
  - Enemy AI
  - Health system
  - Score tracking
- [ ] Complete game examples (2-3 games)
  - Pong clone
  - Breakout clone
  - Simple platformer
- [ ] Each example fully documented
- [ ] Godot project files included

**Estimated Effort**: 5-7 days

---

#### 3. API Documentation

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Reference documentation for all features

**Scope**:

- [ ] Complete language reference
- [ ] All Godot types documented
- [ ] All callbacks documented
- [ ] Built-in functions documented
- [ ] Code examples for each feature
- [ ] Generated API docs from code comments

**Estimated Effort**: 4-5 days

---

#### 4. Tutorial Series

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Guided learning path for new users

**Scope**:

- [ ] Beginner series (5-7 tutorials)
  - Variables and types
  - Functions and control flow
  - Godot integration basics
  - Making your first game
- [ ] Intermediate series (3-5 tutorials)
  - State machines
  - Event systems with signals
  - Scene management
- [ ] Video tutorials (optional)

**Estimated Effort**: 7-10 days

---

#### 5. Migration Guides

**Status**: 🔴 Not Started  
**Priority**: Low  
**Rationale**: Help users transition from GDScript

**Scope**:

- [ ] GDScript to FerrisScript comparison
- [ ] Common patterns translation
- [ ] When to use FerrisScript vs GDScript
- [ ] Performance comparison

**Estimated Effort**: 2-3 days

---

### Medium Priority

#### 5. Custom Properties

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Expose script variables to Godot Inspector

**Scope**:

- [ ] `@export` annotation
- [ ] Property types (int, float, string, etc.)
- [ ] Property hints (range, file, etc.)
- [ ] Read from Inspector
- [ ] Watch for changes

**Example**:

```rust
@export
let speed: f32 = 100.0;

@export(range: 0.0, 1.0)
let volume: f32 = 0.5;

fn _process(delta: f32) {
    self.position.x += speed * delta;
}
```

**Tests**: ~8-10 new tests
**Estimated Effort**: 4-5 days

---

### Additional Tooling Features

#### Hot Reload

**Status**: 🔴 Not Started  
**Priority**: Medium  
**Rationale**: Faster iteration during development

**Scope**:

- [ ] Detect file changes
- [ ] Recompile changed scripts
- [ ] Reload without restarting Godot
- [ ] Preserve state (if possible)

**Benefits**:

- Save seconds on every code change
- See changes immediately in running game
- Dramatically improves workflow

**Tests**: Integration tests
**Estimated Effort**: 7-10 days

---

#### REPL (Read-Eval-Print Loop)

**Status**: 🔴 Not Started  
**Priority**: Low

**Scope**:

- [ ] Interactive FerrisScript shell
- [ ] Evaluate expressions
- [ ] Test code snippets
- [ ] Inspect variables

**Use Cases**:

- Quick testing of syntax
- Learning the language
- Debugging expressions

**Tests**: REPL tests
**Estimated Effort**: 5-7 days

---

### Low Priority (v0.2.0+)

- [ ] Debugger integration (breakpoints, stepping)
- [ ] Profiler integration
- [ ] Documentation generator
- [ ] Snippet library
- [ ] Online playground
- [ ] Package manager

---

## 🚀 Performance Improvements

### Compiler Optimizations

- [ ] **Constant folding**: Evaluate `2 + 3` at compile time → `5`
- [ ] **Dead code elimination**: Remove unreachable code
- [ ] **Inlining**: Inline small functions
- [ ] **Type-based optimizations**: Use known types to skip checks

### Runtime Optimizations

- [ ] **Variable lookup optimization**: HashMap instead of linear scan
- [ ] **Bytecode compilation**: Compile to bytecode instead of AST interpretation
- [ ] **JIT compilation**: Consider for v0.2.0+
- [ ] **Reference counting**: Smart pointers for memory management

### Benchmarking

- [ ] Create comprehensive benchmark suite
- [ ] Compare with GDScript performance
- [ ] Track performance across versions
- [ ] Document performance characteristics

**Target**: Within 2x of GDScript performance for v0.1.0

---

## 📊 Success Metrics for v0.1.0

### Quantitative Goals

- [ ] **Tests**: 200+ passing tests (current: 96)
- [ ] **Test Coverage**: ≥ 80% (with coverage reporting)
- [ ] **Performance**: Within 2x of GDScript on benchmarks
- [ ] **Documentation**: 100% of public APIs documented
- [ ] **Examples**: 20+ example scripts covering all features
- [ ] **LSP Features**: Autocomplete, go-to-definition, hover docs working
- [ ] **Editor Support**: Syntax highlighting in at least 2 editors (VS Code + one more)

### Qualitative Goals

- [ ] **Developer Experience**: LSP makes coding pleasant - **HIGHEST PRIORITY**
- [ ] **Editor Integration**: First-class scripting experience from day one
- [ ] **Godot API Coverage**: Can build simple interactive 2D games
- [ ] **Error Messages**: Developers can understand and fix errors immediately
- [ ] **Usability**: Can build a simple 2D game (Pong, Breakout, etc.)
- [ ] **Onboarding**: New users can get started in < 10 minutes
- [ ] **Community**: 5+ external contributors
- [ ] **Adoption**: 10+ GitHub stars, 3+ forks

### Real-World Validation

- [ ] **Build a demo game**: Create a complete playable game in FerrisScript
  - Target: Pong or Breakout clone
  - Use arrays, loops, match expressions
  - Use Godot integration features
  - Document the experience

- [ ] **Get external feedback**: Have 3-5 developers try FerrisScript
  - Collect pain points
  - Prioritize improvements
  - Validate use cases

---

## 🗓️ Development Phases (Revised Priority)

> **Strategic Change**: Phases have been reordered to prioritize usability and adoption over language features.

### Phase 1: Editor Integration & Tooling (6-8 weeks) 🔥 **NEW PRIORITY**

1. Syntax highlighting & VS Code extension (1 week)
2. LSP foundation (3-4 weeks)
3. Error message improvements (1-2 weeks)
4. Documentation & onboarding (1 week)

**Goal**: Enable first-class developer experience from day one

---

### Phase 2: Godot Integration & API Coverage (4-6 weeks) 🔥 **HIGH PRIORITY**

1. Signal support (2 weeks)
2. Additional callbacks (`_input`, `_physics_process`) (1 week)
3. Additional types (Color, Rect2, Transform2D) (1-2 weeks)
4. Node query functions (1 week)
5. Testing & integration (1 week)

**Goal**: Enable real 2D game development with comprehensive Godot API

---

### Phase 3: Core Language Features (6-10 weeks) - **In Parallel**

1. Arrays (2 weeks)
2. For loops (1 week)
3. Match expressions (2 weeks)
4. String interpolation (1 week)
5. Enums (1-2 weeks)
6. Structs (2 weeks)
7. Testing & bug fixes (1 week)

**Goal**: Add powerful language features to complement the solid foundation

---

### Phase 4: Advanced Features & Polish (3-4 weeks)

1. Hot reload (2 weeks)
2. Performance benchmarking & optimization (1 week)
3. Demo game development (1 week)
4. Documentation & examples (1 week)
5. Release preparation (2-3 days)

**Goal**: Polish and validate for production use

---

**Total Estimated Time**: 19-28 weeks (~5-7 months)

**Key Change**: Phases 1 and 2 are now swapped, with editor/tooling as the highest priority, followed by Godot integration. Language features can be developed in parallel with Phases 1-2.

---

## 🎯 Milestones (Revised)

> **Note**: Milestone order has been adjusted to reflect the new prioritization strategy.

### Milestone 1: Editor Integration ⚡ **NEW FIRST PRIORITY**

**Target**: End of Week 6-8

- Syntax highlighting working
- Basic LSP working  
- VS Code extension available
- Improved error messages
- Real-time syntax errors in editor
- ~15-20 new tests

**Success Criteria**: Developers have a pleasant editing experience

---

### Milestone 2: Godot API Coverage 🎮 **NEW SECOND PRIORITY**

**Target**: End of Week 14

- Signals working
- New callbacks working (`_input`, `_physics_process`)
- Additional types working (Color, Rect2, Transform2D)
- Node query functions working
- Updated Godot examples
- ~40-50 new tests

**Success Criteria**: Can build simple interactive games with current language features

---

### Milestone 3: Core Language Features ✨

**Target**: End of Week 22

- Arrays working
- For loops working
- Match expressions working
- String interpolation working
- ~60-70 new tests
- Updated examples

**Success Criteria**: Language has essential features for game logic

---

### Milestone 4: Advanced Features & Polish

**Target**: End of Week 26

- Hot reload working
- Enums and structs working
- Performance optimized
- ~20-30 new tests

**Success Criteria**: Production-ready features

---

### Milestone 5: v0.1.0 Release 🚀

**Target**: End of Week 28

- All features complete
- Demo game built
- Documentation complete
- Performance validated
- Community feedback incorporated

**Success Criteria**: Ready for public release and real-world use

---

## 🚫 Explicitly Out of Scope for v0.1.0

**Language Features**:

- ❌ Macros
- ❌ Traits/interfaces
- ❌ Generics
- ❌ Async/await
- ❌ Unsafe blocks
- ❌ Modules/imports
- ❌ Package system

**Godot Features**:

- ❌ 3D support (save for v0.2.0+)
- ❌ Advanced physics
- ❌ Networking
- ❌ VR/AR
- ❌ Mobile-specific features
- ❌ Web export

**Tooling**:

- ❌ Full debugger (save for v0.2.0+)
- ❌ Profiler
- ❌ Package manager
- ❌ Build system (beyond Cargo)

---

## 📝 Release Planning

### Pre-Release (v0.1.0-alpha, v0.1.0-beta)

Consider alpha/beta releases for early feedback:

- **v0.1.0-alpha.1**: After Milestone 1 (editor integration & LSP)
- **v0.1.0-alpha.2**: After Milestone 2 (Godot API coverage)
- **v0.1.0-beta.1**: After Milestone 3 (core language features)
- **v0.1.0**: Final release after all testing

**Note**: Alpha releases can ship **without** arrays/loops/match if editor integration and Godot API are solid, enabling early adoption and feedback.

### v0.1.0 Release

- Tag: `v0.1.0`
- Full changelog
- Migration guide from v0.0.X
- Blog post/announcement
- Demo game showcase
- Video tutorial

---

## 🤝 Community & Contribution

### Governance

- Establish contribution guidelines for v0.1.0 development
- Create RFC (Request for Comments) process for major features
- Set up regular dev meetings/updates
- Create project board for tracking

### Collaboration

- Break features into small, contributor-friendly tasks
- Good first issue tags
- Mentor new contributors
- Recognize contributions

---

## 📚 Documentation for v0.1.0

### New Documentation Needed

- [ ] Language reference (complete syntax guide)
- [ ] Godot integration guide (comprehensive)
- [ ] Tutorial series (beginner to advanced)
- [ ] API reference (auto-generated)
- [ ] Migration guide (v0.0.X → v0.1.0)
- [ ] Performance guide
- [ ] LSP user guide

### Updated Documentation

- [ ] README (new features, examples)
- [ ] ARCHITECTURE (reflect new features)
- [ ] CONTRIBUTING (updated for v0.1.0 workflow)
- [ ] RELEASE_NOTES (complete v0.1.0 notes)

---

## 🔮 Looking Ahead to v0.2.0

**Potential Focus Areas**:

1. **3D Support**: Expand to 3D games
2. **Advanced Tooling**: Full debugger, profiler
3. **Performance**: Bytecode compilation, JIT
4. **Advanced Language Features**: Traits, generics
5. **Package System**: Import other FerrisScript libraries

**Target**: 6-12 months after v0.1.0

---

## 🔮 Additional Opportunities from v0.0.3 (Workstream Prompt Improvements)

### Low Priority Items (v0.1.0+)

**1. Phase-Specific Prompt Variations** (2-3 days)

**Opportunity**: Create specialized prompt variants for different phase types (implementation, documentation, release, investigation).

**Benefits**: More targeted guidance, reduced prompt length, better alignment with phase characteristics

**Rationale**: Need more phase execution data to identify patterns worth specializing

**Blocker**: No, but needs data collection across multiple versions first

---

**2. Version-Specific Context Validation** (1 day)

**Opportunity**: Add validation to catch version-specific path references (e.g., hardcoded `docs/v0.0.2/` in generic templates).

**Benefits**: Prevents version-specific references in generic templates, maintains reusability

**Rationale**: Manual review working fine, low frequency problem

**Blocker**: No, nice-to-have automation

---

**3. Prompt Effectiveness Metrics Dashboard** (2-3 days)

**Opportunity**: Create dashboard tracking time estimation accuracy, date accuracy, LEARNINGS.md update rate, TODO discipline, link check pass rate.

**Benefits**: Data-driven prompt improvements, identify persistent issues, celebrate improvements

**Rationale**: Requires data from multiple prompt-guided workstreams (v0.0.3-v0.0.5+)

**Blocker**: No, but needs data collection period first

---

**4. Error Code Telemetry** (Investigation Phase)

**Discovery from v0.0.3 Phase 1**: Structured error codes enable tracking which errors users encounter most frequently.

**Opportunity**: Privacy-respecting, opt-in telemetry to identify:

- Most common user errors (prioritize documentation/error messages)
- Confusing error messages (improve wording)
- Missing error codes (gaps in coverage)

**Investigation Needed**: Opt-in telemetry design, privacy considerations, storage/analysis approach

**Rationale**: Valuable for production-ready release (v0.1.0) to understand user experience

---

**5. Error Code Localization** (Investigation Phase)

**Discovery from v0.0.3 Phase 1**: Error code enum provides centralization point for all error messages.

**Opportunity**: Future internationalization (i18n) - translate error descriptions while keeping error codes stable, provide localized "How to Fix" guidance.

**Investigation Needed**: Which languages to support first, translation workflow, community contributions

**Rationale**: Consider for post-v0.1.0 if international adoption grows

---

**6. Automation Decision Framework Implementation** (v0.1.0)

**Discovery from v0.0.3 Phase 4**: Need systematic approach to decide when to automate vs document vs roadmap future automation.

**Opportunity**: Implement automation decision framework from Phase 4 learnings:

- **Phase 1**: Type synchronization validation scripts
  - Script to compare VS Code completion types with compiler Type enum
  - CI check to detect type mismatches on PRs
  - Exit with error if VS Code types drift from compiler
  - Estimated effort: 2-3 days

- **Phase 2**: Build automation (local development)
  - Pre-commit hooks for TypeScript compilation in VS Code extension
  - npm scripts for unified build/test/lint workflows
  - VS Code tasks for automatic TypeScript watch mode
  - Estimated effort: 1-2 days

- **Phase 3**: CI/CD pipeline for VS Code extension
  - GitHub Actions workflow triggered on `extensions/vscode/**` changes
  - Steps: npm install → compile → lint → build VSIX
  - Upload VSIX as build artifact
  - Run on pull requests and develop branch
  - Estimated effort: 2-3 days

- **Phase 4**: Release automation (v0.1.0+)
  - Automated VSIX creation on version tags
  - Upload to GitHub releases automatically
  - Marketplace publishing automation (investigate)
  - Estimated effort: 3-4 days

**Benefits**:

- Prevents type drift between VS Code and compiler
- Catches build failures early in PRs
- Standardizes local development workflow
- Reduces manual release overhead

**Rationale**: Phase 4 identified clear automation needs. Framework provides incremental path from manual → validated → automated.

**Documentation**: See `docs/archive/prompt/development/PROMPT_IMPROVEMENTS_PHASE4.md` for detailed framework and decision criteria.

**Blocker**: No blockers. Phase 1 (validation) can start immediately after v0.0.3 merges. Phases 2-4 can proceed in parallel with feature work.

---

**7. GitHub CLI PR Creation Helper Script** (v0.1.0)

**Discovery from v0.0.3 Phase 4**: Backtick escaping issues when creating PRs with inline markdown bodies.

**Opportunity**: Create standardized helper script for PR creation:

```powershell
# scripts/create-pr.ps1
param(
    [Parameter(Mandatory=$true)]
    [string]$Title,
    
    [Parameter(Mandatory=$true)]
    [string]$BodyFile,
    
    [string]$Base = "develop"
)

# Ensure temp directory exists
if (-not (Test-Path "temp")) { 
    New-Item -ItemType Directory -Path "temp" | Out-Null 
}

# Copy body file to temp (gitignored location)
Copy-Item $BodyFile "temp/pr-body.txt"

# Create PR
gh pr create --base $Base --title $Title --body-file "temp/pr-body.txt"
```

**Usage**: `.\scripts\create-pr.ps1 -Title "feat: Feature" -BodyFile "pr-description.md"`

**Benefits**:

- No shell escaping issues (always uses --body-file)
- Consistent temp/ directory usage (gitignored)
- Cross-platform compatible (PowerShell Core + Bash variant)
- Can add validation (required sections, markdown lint)

**Estimated Effort**: 1 day (PowerShell + Bash variants + documentation)

**Documentation**: See `docs/archive/prompt/development/GITHUB_CLI_PR_CREATION.md`

**Blocker**: No blockers. Can implement immediately.

---

### Future Investigation

**8. Integration with GitHub Copilot Workspace** (Timeline: TBD)

**Opportunity**: As GitHub Copilot Workspace evolves, adapt workstream prompt for:

- Multi-file context awareness
- Long-running workstream sessions
- Integration with GitHub Issues/Projects
- Automated PR creation with template

**Investigation Needed**: GitHub Copilot Workspace capabilities, prompt format compatibility, migration strategy

**Rationale**: Watch for GitHub announcements, experiment when GA available

**Blocker**: Depends on GitHub Copilot Workspace release timeline

---

**Last Updated**: October 7, 2025  
**Maintainer**: @dev-parkins  
**Status**: 🟡 Planning (Reprioritized)

---

## 📢 Recent Changes

### Roadmap Reprioritization (October 2025)

This roadmap has been **strategically reprioritized** based on community feedback and adoption goals:

**What Changed**:

- ⚡ **Editor Integration & LSP** moved to **HIGHEST PRIORITY** (was Phase 3, now Phase 1)
- 🎮 **Godot API Coverage** elevated to **HIGH PRIORITY** (signals, callbacks, types)
- 📚 **Enhanced Documentation & Onboarding** added as HIGH PRIORITY
- 🔧 **Improved Error Reporting** elevated to CRITICAL PRIORITY
- 📦 **Arrays & For Loops** moved to **MEDIUM PRIORITY** (still important, but not blocking)

**Rationale**:

- **Usability First**: Developers need excellent tooling to be productive
- **API Parity**: Comprehensive Godot integration enables real projects
- **Parallel Development**: Language features can be added alongside editor/API work
- **Faster Adoption**: Ship frequent minor releases with incremental improvements
- **Community Engagement**: Better onboarding and documentation reduce friction

**Impact on Timeline**:

- Overall timeline remains ~5-7 months
- Early alpha releases focus on editor experience and API coverage
- Language features follow in subsequent releases
- More frequent, smaller releases for faster iteration

---

**Note**: This roadmap is ambitious. Priorities may shift based on:

- Community feedback
- Technical challenges discovered
- Resource availability
- User adoption patterns

The goal is to make FerrisScript **practical and delightful** for Godot game development! 🦀🎮
