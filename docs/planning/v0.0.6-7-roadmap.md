# FerrisScript v0.0.6-7 Roadmap 🦀

**Versions**: 0.0.6-7 (Patch Releases)  
**Focus**: Language Features (Optional)  
**Timeline**: 4-6 weeks (can overlap with other work)  
**Prerequisites**: v0.0.5 (LSP working)

---

## 🎯 Overview

**Strategic Goal**: Add core language features in preparation for v0.1.0 release.

**Key Priorities**:

1. Array/list types
2. For loops
3. Match expressions
4. String interpolation

**Alignment with v0.1.0 Strategy**: With editor integration (LSP) and Godot API complete, now is the time to add powerful language features. These were **deprioritized** in the roadmap revision but remain important for v0.1.0.

**Note**: These versions are marked "optional" because:

- They can be developed in parallel with v0.0.4-5
- They could ship as v0.0.6 and v0.0.7 separately
- They could be combined into a single release
- They could be merged directly into v0.1.0 if timeline permits

---

## 📦 High Priority Deliverables (v0.0.6)

### 1. Array/List Types

**Status**: Not Started  
**Priority**: High (was Critical in original roadmap)

**Rationale**: Essential for game development (inventory, enemies, bullets, etc.). Enables realistic game logic.

**Scope**:

- [ ] Array type syntax: `[i32]`, `[String]`, `[Node]`
- [ ] Array literals: `[1, 2, 3]`, `["a", "b", "c"]`
- [ ] Array indexing: `arr[0]`, `arr[i]`
- [ ] Array methods:
  - `len() -> i32` - Get array length
  - `push(value)` - Add element to end
  - `pop() -> T` - Remove and return last element
  - `contains(value) -> bool` - Check if value exists
  - `clear()` - Remove all elements
  - `remove_at(index)` - Remove element at index
- [ ] Type checking for homogeneous arrays
- [ ] Integration with Godot Array type
- [ ] Array iteration (prerequisite for for loops)

**Example**:

```rust
let mut enemies: [Node] = [];
let numbers: [i32] = [1, 2, 3, 4, 5];

fn _ready() {
    enemies.push(get_node("Enemy1"));
    enemies.push(get_node("Enemy2"));
    print(enemies.len()); // 2
    
    if enemies.contains(get_node("Enemy1")) {
        print("Enemy1 found!");
    }
}

fn _process(delta: f32) {
    let mut i: i32 = 0;
    while i < enemies.len() {
        // Process each enemy
        let enemy: Node = enemies[i];
        i += 1;
    }
}
```

**Implementation Details**:

- Add array type to type system
- Implement array value in runtime
- Add array indexing operator
- Add array methods as built-ins
- Handle bounds checking
- Integration with Godot's Array class

**Estimated Effort**: 5-7 days

**Tests**: ~15-20 new tests

**Components Affected**: Lexer, parser, type system, runtime

---

### 2. For Loops

**Status**: Not Started  
**Priority**: Medium (was Critical in original roadmap)

**Rationale**: Much cleaner than while loops for iteration. Complements arrays perfectly.

**Scope**:

- [ ] Range syntax: `for i in 0..10`
- [ ] Inclusive ranges: `for i in 0..=10`
- [ ] Array iteration: `for enemy in enemies`
- [ ] Break statement
- [ ] Continue statement
- [ ] Nested loops

**Example**:

```rust
fn _process(delta: f32) {
    // Range loop
    for i in 0..10 {
        print(i);
    }
    
    // Inclusive range
    for i in 0..=10 {
        print(i); // Prints 0 through 10
    }
    
    // Array iteration
    for enemy in enemies {
        enemy.position.x += 10.0;
    }
    
    // With break and continue
    for i in 0..100 {
        if i == 50 {
            break; // Exit loop
        }
        if i % 2 == 0 {
            continue; // Skip even numbers
        }
        print(i);
    }
}
```

**Implementation Details**:

- Add `for`, `in`, `break`, `continue` keywords
- Add for loop to AST
- Implement range iterator
- Implement array iterator
- Handle break and continue in runtime
- Type checking for iterable types

**Estimated Effort**: 3-5 days

**Tests**: ~10-15 new tests

**Components Affected**: Lexer, parser, type system, runtime

---

## 📦 Medium Priority Deliverables (v0.0.7)

**Note**: v0.0.7 now includes Node Invalidation Phase 2 from the node safety research. This fits thematically with Godot API expansion work.

### 1. Node Invalidation Phase 2 🛡️ NEW

**Status**: Not Started  
**Priority**: 🛡️ **MEDIUM** (Robustness improvement, builds on Phase 1 from v0.0.5)

**Rationale**: Migrate from string-based node tracking to ObjectID-based weak references. Phase 1 (v0.0.5) adds basic validity checking, but Phase 2 provides a more robust foundation using Godot's native ObjectID system. This fits naturally with Godot API expansion work.

**Scope**:

- [ ] Add ObjectID to NodeHandle structure
- [ ] Capture ObjectID at node registration time
- [ ] Implement ObjectID-based lookup and validation
- [ ] Migrate all node query functions to use ObjectID
- [ ] Add automatic cleanup of invalid handles
- [ ] Performance testing vs Phase 1 string-based approach
- [ ] Update examples to demonstrate robustness

**Example**:

```rust
// Phase 2: ObjectID-based (more robust)
// Internal implementation:
// - NodeHandle stores ObjectID (u64)
// - Lookup uses ObjectID::from_instance_id()
// - Automatic detection of freed nodes
// - No string path needed for validation

let player: Node = get_node("Player");
// Internally: ObjectID captured on first access
// Future accesses use ObjectID for validation
// Even if node moves in tree, ObjectID stays valid
```

**Implementation Details**:

- Modify NodeHandle struct to include ObjectID
- Bind Godot's `get_instance_id()` in godot_bind
- Update node registration to capture ObjectID
- Implement ObjectID-based validation helper
- Migrate get_node, find_child, get_parent
- Add cleanup logic for freed nodes
- Benchmark performance impact

**Estimated Effort**: 3-4 hours (1 premium request)  
**Tests**: ~8-10 new tests for ObjectID handling  
**Dependencies**: Phase 1 (v0.0.5) for basic validity checking  
**Future Work**: Phase 3 (weak reference API) deferred to post-v0.1.0

**Reference**: See `docs/planning/v0.0.4/NODE_INVALIDATION_RESEARCH.md` for full 3-phase plan and research findings.

---

### 2. Match Expressions

**Status**: Not Started  
**Priority**: Medium (was High in original roadmap)

**Rationale**: Rust's killer feature. Great for state machines and game logic.

**Scope**:

- [ ] Match on integers: `match x { 1 => ..., 2 => ..., _ => ... }`
- [ ] Match on booleans: `match flag { true => ..., false => ... }`
- [ ] Match on strings: `match state { "idle" => ..., "walking" => ... }`
- [ ] Wildcard pattern: `_`
- [ ] Match with blocks
- [ ] Exhaustiveness checking (warn if not all cases covered)
- [ ] Match as expression (returns value)

**Example**:

```rust
let mut state: String = "idle";

fn _process(delta: f32) {
    match state {
        "idle" => {
            // Idle behavior
            if check_input() {
                state = "walking";
            }
        },
        "walking" => {
            self.position.x += 50.0 * delta;
            if !check_input() {
                state = "idle";
            }
        },
        "jumping" => {
            self.position.y -= 100.0 * delta;
        },
        _ => {
            print("Unknown state!");
        }
    }
}

// Match as expression
let color: Color = match health {
    0..=25 => Color::RED,
    26..=50 => Color::YELLOW,
    _ => Color::GREEN
};
```

**Implementation Details**:

- Add `match` keyword
- Add match expression to AST
- Implement pattern matching in runtime
- Type checking for match arms
- Exhaustiveness checking
- Handle match as expression

**Estimated Effort**: 5-7 days

**Tests**: ~15-20 new tests

**Components Affected**: Lexer, parser, type system, runtime

---

### 3. String Interpolation

**Status**: Not Started  
**Priority**: Low-Medium

**Rationale**: Much nicer than string concatenation. Quality of life improvement.

**Scope**:

- [ ] Format string syntax: `f"Hello, {name}!"`
- [ ] Expression interpolation: `f"Score: {score * 10}"`
- [ ] Type conversion (int/float to string)
- [ ] Nested expressions: `f"Result: {x + y}"`
- [ ] Escape sequences: `f"Price: \${price}"`

**Example**:

```rust
let name: String = "Player";
let score: i32 = 100;
let health: f32 = 75.5;

fn _ready() {
    print(f"Hello, {name}!");
    print(f"Your score is {score}.");
    print(f"Health: {health}%");
    print(f"Double score: {score * 2}");
    print(f"Price: \${99}"); // Escaped dollar sign
}
```

**Implementation Details**:

- Add `f"..."` string literal syntax
- Parse interpolation expressions
- Implement string formatting
- Type conversion for primitives
- Handle escape sequences

**Estimated Effort**: 2-3 days

**Tests**: ~8-10 new tests

**Components Affected**: Lexer, parser, runtime

---

## 🎯 Success Metrics

### Quantitative Goals

- [ ] Arrays working with all methods
- [ ] For loops support ranges and arrays
- [ ] Match expressions handle all basic types
- [ ] String interpolation works with all types
- [ ] 50-60 new tests added
- [ ] All existing tests passing

### Qualitative Goals

- [ ] Can build realistic game logic
- [ ] Code is more concise and readable
- [ ] State machines feel natural with match
- [ ] Array manipulation is intuitive

---

## 📋 Possible Release Strategy

### Option 1: Two Separate Releases

**v0.0.6**: Arrays + For Loops (3-4 weeks)  
**v0.0.7**: Match + String Interpolation (2-3 weeks)

**Pros**:

- Smaller, more focused releases
- Faster delivery of arrays (most needed feature)
- Can gather feedback between releases

**Cons**:

- More release overhead
- Split attention

### Option 2: Combined Release

**v0.0.6**: All language features (5-6 weeks)

**Pros**:

- Single comprehensive release
- All features tested together
- Less release overhead

**Cons**:

- Longer wait for any features
- Larger testing surface

### Option 3: Merge into v0.1.0

Skip v0.0.6-7 entirely and merge work directly into v0.1.0

**Pros**:

- Cleaner version history
- Focus on v0.1.0 quality
- More time for polish

**Cons**:

- No intermediate releases
- Longer gap between releases

**Recommendation**: Option 1 (separate releases) for faster iteration and feedback.

---

## 🔗 Dependencies for v0.1.0

**Enables v0.1.0**:

- ✅ Arrays → Realistic game examples
- ✅ For loops → Clean iteration code
- ✅ Match → State machine examples
- ✅ Complete language foundation → Ready for production

**Critical Path**:

v0.0.5 (LSP) → v0.0.6 (Arrays/Loops) → v0.0.7 (Match/Strings) → v0.1.0

**Parallel Path**:

v0.0.4-5 (LSP + API) can happen in parallel with v0.0.6-7 development if resources allow.

---

## 📝 Notes

### Example Game After v0.0.6-7

With all language features, can build complex games:

```rust
signal score_changed(new_score: i32);

let mut enemies: [Node] = [];
let mut bullets: [Node] = [];
let mut score: i32 = 0;
let mut state: String = "playing";

fn _ready() {
    // Initialize enemies
    for i in 0..5 {
        let enemy: Node = spawn_enemy();
        enemies.push(enemy);
    }
}

fn _input(event: InputEvent) {
    match state {
        "playing" => {
            if event.is_action_pressed("shoot") {
                let bullet: Node = spawn_bullet();
                bullets.push(bullet);
            }
        },
        "paused" => {
            if event.is_action_pressed("unpause") {
                state = "playing";
            }
        },
        _ => {}
    }
}

fn _process(delta: f32) {
    // Update all enemies
    for enemy in enemies {
        enemy.position.x -= 50.0 * delta;
    }
    
    // Update all bullets
    for bullet in bullets {
        bullet.position.x += 200.0 * delta;
    }
    
    // Check collisions
    check_collisions();
}

fn check_collisions() {
    for bullet in bullets {
        for enemy in enemies {
            if collision(bullet, enemy) {
                score += 10;
                emit_signal("score_changed", score);
                print(f"Score: {score}");
            }
        }
    }
}
```

### Release Checklists

**v0.0.6 Release**:

- [ ] Arrays fully tested
- [ ] For loops working
- [ ] LSP updated for new syntax
- [ ] Example game created
- [ ] Documentation updated
- [ ] CHANGELOG.md updated
- [ ] Tag: v0.0.6

**v0.0.7 Release**:

- [ ] Match expressions tested
- [ ] String interpolation working
- [ ] LSP autocomplete updated
- [ ] State machine example
- [ ] Documentation updated
- [ ] CHANGELOG.md updated
- [ ] Tag: v0.0.7

---

## 🚫 Out of Scope

The following are explicitly **NOT** included in v0.0.6-7:

- ❌ Enum types (can be added in v0.1.0)
- ❌ Struct types (can be added in v0.1.0)
- ❌ Dictionaries/HashMaps
- ❌ Tuple types
- ❌ Pattern matching (destructuring)
- ❌ Method calls on types
- ❌ Generics
- ❌ Traits

These features are deferred to v0.1.0 or later.

---

## 📝 Additional Tasks from v0.0.2 Deferral

The following items were deferred from v0.0.2 and align with v0.0.6's performance optimization theme:

### Performance Optimization

**Priority**: Medium-High

- [ ] **Memory leak checks** - Detect and fix memory leaks:
  - Use Valgrind or similar tools
  - Profile memory usage over time
  - Test with long-running scripts
  - Add memory leak tests to CI

- [ ] **Variable lookup optimization (HashMap)** - Improve runtime performance:
  - Replace linear search with HashMap for variable lookup
  - Benchmark improvement
  - Measure impact on execution speed

- [ ] **Performance profiling (flamegraph)** - Identify bottlenecks:
  - Generate flamegraphs for hot paths
  - Profile compiler and runtime
  - Document performance characteristics
  - Identify optimization opportunities

- [ ] **Optimize identified bottlenecks** - Address performance issues:
  - Optimize based on profiling results
  - Target hot paths in compiler/runtime
  - Measure improvements
  - Document optimizations

**Rationale**: Current performance is acceptable, but proactive optimization improves user experience. After language features are complete, good time to focus on performance.

**Estimated Effort**: 5-7 days total

---

### Testing & Quality Assurance

**Priority**: Medium

- [ ] **Property-based testing (proptest)** - Advanced testing technique:
  - Add proptest dependency
  - Generate random test inputs
  - Test parser with random valid/invalid code
  - Test type checker with random type combinations
  - Test runtime with random operations

**Rationale**: Advanced testing technique ensures robustness. Not critical, but valuable for long-term quality.

**Estimated Effort**: 3-4 days

---

**Note**: These deferred items complement v0.0.6's language features. Performance optimizations ensure new features (arrays, loops) run efficiently. Property-based testing validates complex interactions between new language constructs.

---

**Last Updated**: October 2025  
**Status**: 🟡 Planning  
**Previous Version**: v0.0.5 (LSP Alpha)  
**Next Version**: v0.1.0 (Production Ready)
